<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tektronix_func_gen API documentation</title>
<meta name="description" content="Tektronix arbitrary function generator control …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tektronix_func_gen</code></h1>
</header>
<section id="section-intro">
<h2 id="tektronix-arbitrary-function-generator-control">Tektronix arbitrary function generator control</h2>
<p><a href="https://www.codefactor.io/repository/github/asvela/tektronix-func-gen"><img alt="CodeFactor Grade" src="https://img.shields.io/codefactor/grade/github/asvela/tektronix-func-gen?style=flat-square"></a>
<a href="https://github.com/asvela/dlc-control/blob/main/LICENSE"><img alt="MIT License" src="https://img.shields.io/github/license/asvela/dlc-control?style=flat-square"></a></p>
<p>Provides basic control of AFG1000 and AFG3000 series Tektronix Arbitrary Function
Generators, possibly also others. This includes setting basic settings such as
selecting functions, transferring or selecting custom waveforms, amplitude and offset
control, phase syncronisation and frequency locking.</p>
<p>API documentation available <a href="https://asvela.github.io/tektronix-func-gen/">here</a>,
or in the repository <a href="docs/index.html">docs/index.html</a>. (To build the documentation
yourself use <a href="https://pdoc3.github.io/pdoc/">pdoc3</a> and run
<code>$ python3 pdoc --html -o ./docs/ tektronix_func_gen</code>.)</p>
<p>Tested on Win10 with NI-VISA and PyVISA v1.11 (if using PyVISA &lt;v1.11 use &lt;v0.4
of this module).</p>
<h3 id="known-issues">Known issues</h3>
<ul>
<li><strong>For TekVISA users:</strong> a <code>pyvisa.errors.VI_ERROR_IO</code> is raised unless the
Call Monitor application that comes with TekVISA is open and capturing
(see issue <a href="https://github.com/asvela/tektronix-func-gen/issues/1">#1</a>).
NI-VISA does not have this issue.</li>
<li>The offset of the built-in DC (flat) function cannot be controlled directly. A
workaround is to transfer a flat custom waveform to a memory location,
see <a href="#flat-function-offset-control">Flat function offset control</a> in this readme.</li>
<li>The frequency limits can in practice be stricter than what is set by the module,
as the module is using the limits for a sine, where as other functions, such as
ramp might have lower limit</li>
</ul>
<h3 id="installation">Installation</h3>
<p>Put the module file in the folder wherein the Python file you will import it
from resides.</p>
<p><strong>Dependencies:</strong></p>
<ul>
<li>The package needs VISA to be installed. It is tested with NI-VISA,
<em>TekVISA might not work</em>, see <code>Known issues</code></li>
<li>The Python packages <code>numpy</code> and <code>pyvisa</code> (&gt;=v1.11) are required</li>
</ul>
<h3 id="usage-through-examples">Usage (through examples)</h3>
<p>An example of basic control</p>
<pre><code class="python">import tektronix_func_gen as tfg

with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT') as fgen:
      fgen.ch1.set_function(&quot;SIN&quot;)
      fgen.ch1.set_frequency(25, unit=&quot;Hz&quot;)
      fgen.ch1.set_offset(50, unit=&quot;mV&quot;)
      fgen.ch1.set_amplitude(0.002)
      fgen.ch1.set_output(&quot;ON&quot;)
      fgen.ch2.set_output(&quot;OFF&quot;)
      # alternatively fgen.ch1.print_settings() to show from one channel only
      fgen.print_settings()
</code></pre>
<p>yields something like (depending on the settings already in use)</p>
<pre><code>Connected to TEKTRONIX model AFG1022, serial XXXXX

Current settings for TEKTRONIX AFG1022 XXXXX

  Setting Ch1   Ch2   Unit
==========================
   output ON    OFF    
 function SIN   RAMP  
amplitude 0.002 1     Vpp
   offset 0.05  -0.45 V
frequency 25.0  10.0  Hz
</code></pre>
<p>Settings can also be stored and restored:</p>
<pre><code class="python">&quot;&quot;&quot;Example showing how to connect, get the current settings of
the instrument, store them, change a setting and then restore the
initial settings&quot;&quot;&quot;
import tektronix_func_gen as tfg
with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT') as fgen:
    fgen.print_settings()
    print(&quot;Saving these settings..&quot;)
    settings = fgen.get_settings()
    print(&quot;Change to 1Vpp amplitude for channel 1..&quot;)
    fgen.ch1.set_amplitude(1)
    fgen.print_settings()
    print(&quot;Reset back to initial settings..&quot;)
    fgen.set_settings(settings)
    fgen.print_settings()
</code></pre>
<h4 id="syncronisation-and-frequency-lock">Syncronisation and frequency lock</h4>
<p>The phase of the two channels can be syncronised with <code>syncronise_waveforms()</code>.
Frequency lock can also be enabled/disabled with <code>set_frequency_lock()</code>:</p>
<pre><code class="python">&quot;&quot;&quot;Example showing the frequency being set to 10Hz and then the frequency
lock enabled, using the frequency at ch1 as the common frequency&quot;&quot;&quot;
import tektronix_func_gen as tfg
with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT', verbose=False) as fgen:
    fgen.ch1.set_frequency(10)
    fgen.set_frequency_lock(&quot;ON&quot;, use_channel=1)
</code></pre>
<h4 id="arbitrary-waveforms">Arbitrary waveforms</h4>
<p>14 bit vertical resolution arbitrary waveforms can be transferred to the 256
available user defined functions on the function generator.
The length of the waveform must be between 2 and 8192 points.</p>
<pre><code class="python">import numpy as np
import tektronix_func_gen as tfg
with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT') as fgen:
      # create waveform
      x = np.linspace(0, 4*np.pi, 8000)
      waveform = np.sin(x)+x/5
      # transfer the waveform (normalises to the vertical waveform range)
      fgen.set_custom_waveform(waveform, memory_num=5, verify=True)
      # done, but let's have a look at the waveform catalogue ..
      print(&quot;New waveform catalogue:&quot;)
      for i, wav in enumerate(fgen.get_waveform_catalogue()): print(&quot;  {}: {}&quot;.format(i, wav))
      # .. and set the waveform to channel 1
      print(&quot;Set new wavefrom to channel 1..&quot;, end=&quot; &quot;)
      fgen.ch1.set_output(&quot;OFF&quot;)
      fgen.ch1.set_function(&quot;USER5&quot;)
      print(&quot;ok&quot;)
      # print current settings
      fgen.print_settings()
</code></pre>
<h5 id="flat-function-offset-control">Flat function offset control</h5>
<p>The offset of the built-in DC function cannot be controlled (the offset command
simply does not work, an issue from Tektronix). A workaround is to transfer a
flat custom waveform (two or more points of half the vertical range
(<code>arbitrary_waveform_resolution</code>)) to a memory location:</p>
<pre><code class="python">with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT') as fgen:
    flat_wfm = int(fgen.arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)
    fgen.set_custom_waveform(flat_wfm, memory_num=255, normalise=False)
    fgen.ch1.set_function(&quot;USER255&quot;)
    fgen.ch1.set_offset(2)
</code></pre>
<p>Note the <code>normalise=False</code> argument.</p>
<h4 id="set-voltage-and-frequency-limits">Set voltage and frequency limits</h4>
<p>Limits for amplitude, voltage and frequency for each channel are kept in a
dictionary <code><a title="tektronix_func_gen.FuncGenChannel.channel_limits" href="#tektronix_func_gen.FuncGenChannel.channel_limits">FuncGenChannel.channel_limits</a></code> (these are the standard limits
for AFG1022)</p>
<pre><code class="python">channel_limits = {
  &quot;frequency lims&quot;: ({&quot;min&quot;: 1e-6, &quot;max&quot;: 25e6}, &quot;Hz&quot;),
  &quot;voltage lims&quot;:   ({&quot;50ohm&quot;: {&quot;min&quot;: -5, &quot;max&quot;: 5},
                      &quot;highZ&quot;: {&quot;min&quot;: -10, &quot;max&quot;: 10}}, &quot;V&quot;),
  &quot;amplitude lims&quot;: ({&quot;50ohm&quot;: {&quot;min&quot;: 0.001, &quot;max&quot;: 10},
                      &quot;highZ&quot;: {&quot;min&quot;: 0.002, &quot;max&quot;: 20}}, &quot;Vpp&quot;)}
</code></pre>
<p>They chan be changed by <code><a title="tektronix_func_gen.FuncGenChannel.set_limit" href="#tektronix_func_gen.FuncGenChannel.set_limit">FuncGenChannel.set_limit()</a></code>, or by using the
<code><a title="tektronix_func_gen.FuncGenChannel.set_stricter_limits" href="#tektronix_func_gen.FuncGenChannel.set_stricter_limits">FuncGenChannel.set_stricter_limits()</a></code> for a series of prompts.</p>
<pre><code class="python">import tektronix_func_gen as tfg
&quot;&quot;&quot;Example showing how limits can be read and changed&quot;&quot;&quot;
with tfg.FuncGen('VISA ADDRESS OF YOUR INSTRUMENT') as fgen:
    lims = fgen.ch1.get_frequency_lims()
    print(&quot;Channel 1 frequency limits: {}&quot;.format(lims))
    print(&quot;Change the lower limit to 2Hz..&quot;)
    fgen.ch1.set_limit(&quot;frequency lims&quot;, &quot;min&quot;, 2)
    lims = fgen.ch1.get_frequency_lims()
    print(&quot;Channel 1 frequency limits: {}&quot;.format(lims))
    print(&quot;Try to set ch1 frequency to 1Hz..&quot;)
    try:
        fgen.ch1.set_frequency(1)
    except NotSetError as err:
        print(err)
</code></pre>
<h4 id="impedance">Impedance</h4>
<p>Unfortunately the impedance (50Ω or high Z) cannot be controlled or read remotely.
Which setting is in use affects the limits of the output voltage. Use the optional
impedance keyword in the initialisation of the <code><a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a></code> object to make the object
aware what limits applies: <code>FuncGen('VISA ADDRESS OF YOUR INSTRUMENT', impedance=("highZ", "50ohm"))</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
.. include:: ./README.md

&#34;&#34;&#34;

import copy
import pyvisa
import numpy as np
from typing import Tuple, List, Union


_VISA_ADDRESS = &#34;USB0::0x0699::0x0353::1731975::INSTR&#34;


def _SI_prefix_to_factor(unit):
    &#34;&#34;&#34;Convert an SI prefix to a numerical factor

    Parameters
    ----------
    unit : str
        The unit whose first character is checked against the list of
        prefactors {&#34;M&#34;: 1e6, &#34;k&#34;: 1e3, &#34;m&#34;: 1e-3}

    Returns
    -------
    factor : float or `None`
        The appropriate factor or 1 if not found in the list, or `None`
        if the unit string is empty
    &#34;&#34;&#34;
    # SI prefix to numerical value
    SI_conversion = {&#34;M&#34;: 1e6, &#34;k&#34;: 1e3, &#34;m&#34;: 1e-3}
    try:  # using the unit&#39;s first character as key in the dictionary
        factor = SI_conversion[unit[0]]
    except KeyError:  # if the entry does not exist
        factor = 1
    except IndexError:  # if the unit string is empty
        factor = None
    return factor


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ERROR CLASSES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##


class NotSetError(Exception):
    &#34;&#34;&#34;Error for when a value cannot be written to the instrument&#34;&#34;&#34;


class NotCompatibleError(Exception):
    &#34;&#34;&#34;Error for when the instrument is not compatible with this module&#34;&#34;&#34;


## ~~~~~~~~~~~~~~~~~~~~~ FUNCTION GENERATOR CLASS ~~~~~~~~~~~~~~~~~~~~~~~~~~ ##


class FuncGen:
    &#34;&#34;&#34;Class for interacting with Tektronix function generator

    Parameters
    ----------
    visa_address : str
        VISA address of the insrument
    impedance : tuple of {&#34;highZ&#34;, &#34;50ohm&#34;}, default (&#34;highZ&#34;,)*2
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA).
        For example `(&#34;highZ&#34;, &#34;50ohm&#34;)` for to use high Z for ch1 and
        50 ohm for ch2
    timeout : int, default 1000
        Timeout in milliseconds of instrument connection
    verify_param_set : bool, default False
        Verify that a value is successfully set after executing a set function
    verbose : bool, default `True`
        Choose whether to print information such as model upon connecting etc
    override_compatibility : str, default `&#34;&#34;`
        If the instrument limits for the model connected to are not known
        `NotCompatibleError` will be raised. To override and use either of
        AFG1022, AFG1062, or AFG3022 limits, use their respecive model names as
        argument. Note that this might lead to unexpected behaviour for custom
        waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.

    Attributes
    ----------
    _visa_address : str
        The VISA address of the instrument
    _id : str
        Comma separated string with maker, model, serial and firmware of
        the instrument
    _inst : `pyvisa.resources.Resource`
        The PyVISA resource
    _arbitrary_waveform_length : list
        The permitted minimum and maximum length of an arbitrary waveform,
        e.g. [2, 8192]
    _arbitrary_waveform_resolution : int
        The vertical resolution of the arbitrary waveform, for instance 14 bit
        =&gt; 2**14-1 = 16383
    _max_waveform_memory_user_locations : int
        The number of the last user memory location available

    Raises
    ------
    pyvisa.Error
        If the supplied VISA address cannot be connected to
    NotCompatibleError
        If the instrument limits for the model connected to are not known
        (Call the class with `override_compatibility=True` to override and
        use AFG1022 limits)
    &#34;&#34;&#34;

    _is_connected = False
    &#34;&#34;&#34;bool: Keeping track of whether the PYVISA connection has been established&#34;&#34;&#34;

    instrument_limits = {}
    &#34;&#34;&#34;dict: Contains the following keys with subdictionaries

        - `frequency lims`
          Containing the frequency limits for the instrument where the keys
          &#34;min&#34; and &#34;max&#34; have values corresponding to minimum and maximum
          frequencies in Hz
        - `voltage lims`
          Contains the maximum absolute voltage the instrument can output
          for the keys &#34;50ohm&#34; and &#34;highZ&#34; according to the impedance setting
        - `amplitude lims`
          Contains the smallest and largest possible amplitudes where the
          keys &#34;50ohm&#34; and &#34;highZ&#34; will have subdictionaries with keys
          &#34;min&#34; and &#34;max&#34;
    &#34;&#34;&#34;

    def __init__(
        self,
        visa_address: str,
        impedance: Tuple[str, str] = (&#34;highZ&#34;,) * 2,
        timeout: int = 1000,
        verify_param_set: bool = False,
        override_compatibility: str = &#34;&#34;,
        verbose: bool = True,
    ):
        self._override_compat = override_compatibility
        self._visa_address = visa_address
        self.verify_param_set = verify_param_set
        &#34;&#34;&#34;bool:  Verify that a value is successfully set after executing a set function&#34;&#34;&#34;
        self.verbose = verbose
        &#34;&#34;&#34;bool: Choose whether to print information such as model upon connecting etc&#34;&#34;&#34;
        self.open(visa_address, timeout)
        self._initialise_model_properties()
        self.channels = (
            self._spawn_channel(1, impedance[0]),
            self._spawn_channel(2, impedance[1]),
        )
        &#34;&#34;&#34;tuple of `FuncGenChannel`: Objects to control the channels&#34;&#34;&#34;
        self.ch1 = self.channels[0]
        &#34;&#34;&#34;`FuncGenChannel`: Short hand for `channels[0]` Object to control channel 1&#34;&#34;&#34;
        self.ch2 = self.channels[1]
        &#34;&#34;&#34;`FuncGenChannel`: Short hand for `channels[1]` Object to control channel 2&#34;&#34;&#34;

    def __enter__(self, **kwargs):
        # The kwargs will be passed on to __init__
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        self.close()

    def open(self, visa_address: str, timeout: int):
        try:
            rm = pyvisa.ResourceManager()
            self._inst = rm.open_resource(visa_address)
        except pyvisa.Error:
            print(f&#34;\nVisaError: Could not connect to &#39;{visa_address}&#39;&#34;)
            raise
        self._is_connected = True
        self.timeout = timeout
        # Clear all the event registers and queues used in the instrument
        # status and event reporting system
        self.write(&#34;*CLS&#34;)
        # Get information about the connected device
        self._id = self.query(&#34;*IDN?&#34;)
        # Second query might be needed due to unknown reason
        if self._id == &#34;&#34;:
            self._id = self.query(&#34;*IDN?&#34;)
        self._maker, self._model, self._serial = self._id.split(&#34;,&#34;)[:3]
        if self.verbose:
            print(
                f&#34;Connected to {self._maker} model {self._model}, &#34;
                f&#34;serial {self._serial}&#34;
            )

    def close(self):
        &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
        if self._is_connected:
            self._inst.close()
            self._is_connected = False

    @property
    def timeout(self) -&gt; int:
        &#34;&#34;&#34;The timeout of the PYVISA connection in milliseconds&#34;&#34;&#34;
        return self._inst.timeout

    @timeout.setter
    def timeout(self, ms: int):
        self._inst.timeout = ms

    def _initialise_model_properties(self):
        &#34;&#34;&#34;Initialises the limits of what the instrument can handle according
        to the instrument model

        Raises
        ------
        NotCompatibleError
            If the connected model is not necessarily compatible with this
            package, slimits are not known.
        &#34;&#34;&#34;
        if np.any([&#34;AFG1022&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 8192]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 255
        elif np.any([&#34;AFG1062&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 60e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 1e6]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 31
        elif np.any([&#34;AFG3022&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.01, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.02, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 65536]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 4
        else:
            msg = (
                f&#34;Model {self._model} might not be fully supported!\n&#34;
                &#34;  The module has been tested with AFG1022, AFG1062, and AFG3022.\n&#34;
                &#34;  To initiate and use the module as any of these, call the\n&#34;
                &#34;  class with for instance `override_compatibility=&#39;AFG1022&#39;`\n&#34;
                &#34;  Note that this might lead to unexpected behaviour\n&#34;
                &#34;  for custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.&#34;
            )
            raise NotCompatibleError(msg)

    def write(self, command: str, custom_err_message: str = None) -&gt; int:
        &#34;&#34;&#34;Write a VISA command to the instrument

        Parameters
        ----------
        command : str
            The VISA command to be written to the instrument
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        bytes : int
            Number of bytes tranferred

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        num_bytes = self._inst.write(command)
        self._check_pyvisa_status(command, custom_err_message=custom_err_message)
        return num_bytes

    def query(self, command: str, custom_err_message: str = None) -&gt; str:
        &#34;&#34;&#34;Query the instrument

        Parameters
        ----------
        command : str
            The VISA query command
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        str
            The instrument&#39;s response

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        response = self._inst.query(command).strip()
        self._check_pyvisa_status(command, custom_err_message=custom_err_message)
        return response

    def _check_pyvisa_status(self, command: str, custom_err_message: str = None):
        &#34;&#34;&#34;Check the last status code of PyVISA

        Parameters
        ----------
        command : str
            The VISA write/query command

        Returns
        -------
        status : pyvisa.constants.StatusCode
            Return value of the library call

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        status = self._inst.last_status
        if not status == pyvisa.constants.StatusCode.success:
            if custom_err_message is not None:
                msg = (
                    f&#34;Could not {custom_err_message}: pyvisa returned &#34;
                    f&#34;StatusCode {status} ({str(status)})&#34;
                )
                raise RuntimeError(msg)
            msg = (
                f&#34;Writing/querying command {command} failed: pyvisa returned &#34;
                f&#34;StatusCode {status} ({str(status)})&#34;
            )
            raise RuntimeError(msg)
        return status

    def get_error(self) -&gt; str:
        &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

        Returns
        -------
        str
            Error/event number, description of error/event
        &#34;&#34;&#34;
        return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)

    def _spawn_channel(self, channel: int, impedance: str) -&gt; &#34;FuncGenChannel&#34;:
        &#34;&#34;&#34;Wrapper function to create a `FuncGenChannel` object for
        a channel -- see the class docstring&#34;&#34;&#34;
        return FuncGenChannel(self, channel, impedance)

    def get_settings(self) -&gt; List[dict]:
        &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

        Returns
        -------
        settings : list of dicts
            [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
            with keys output, function, amplitude, offset, and frequency with
            corresponding values
        &#34;&#34;&#34;
        return [ch.get_settings() for ch in self.channels]

    def print_settings(self):
        &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
        settings = self.get_settings()
        # Find the necessary padding for the table columns
        # by evaluating the maximum length of the entries
        key_padding = max([len(key) for key in settings[0].keys()])
        ch_paddings = [
            max([len(str(val[0])) for val in ch_settings.values()])
            for ch_settings in settings
        ]
        padding = [key_padding] + ch_paddings
        print(f&#34;\nCurrent settings for {self._maker} {self._model} {self._serial}\n&#34;)
        row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
        table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;, &#34;Unit&#34;, padd=padding)
        print(table_header)
        print(&#34;=&#34; * len(table_header))
        for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(
            settings[0].items(), settings[1].items()
        ):
            print(
                row_format.format(ch1key, str(ch1val), str(ch2val), unit, padd=padding)
            )

    def set_settings(self, settings: List[dict]):
        &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

        (Each channel is turned off before applying the changes to avoid
        potentially harmful combinations)

        Parameteres
        -----------
        settings : list of dicts
            List of settings dictionaries as returned by `get_settings`, first
            entry for channel 1, second for channel 2. The dictionaries should
            have keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        for ch, s in zip(self.channels, settings):
            ch.set_settings(s)

    def syncronise_waveforms(self):
        &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

        Note: Does NOT enable the frequency lock that can be enabled on the
        user interface of the instrument)
        &#34;&#34;&#34;
        self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)

    def get_frequency_lock(self) -&gt; bool:
        &#34;&#34;&#34;Check if frequency lock is enabled

        Returns
        -------
        bool
            `True` if frequency lock enabled
        &#34;&#34;&#34;
        # If one is locked so is the other, so just need to check one
        return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1

    def set_frequency_lock(self, state: str, use_channel: int = 1):
        &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
        frequency and phase of their signals, also after adjustments.

        See also `FuncGen.syncronise_waveforms` for one-time sync only.

        Parameters
        ----------
        state : {&#34;ON&#34;, &#34;OFF&#34;}
            ON to enable, OFF to disable the lock
        use_channel : int, default 1
            Only relevant if turning the lock ON: The channel whose frequency
            shall be used as the common freqency
        &#34;&#34;&#34;
        if self.verbose:
            if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
                print(
                    f&#34;(!) {self._model}: Tried to disable frequency lock, but &#34;
                    f&#34;frequency lock was not enabled&#34;
                )
                return
            if state.lower() == &#34;on&#34; and self.get_frequency_lock():
                print(
                    f&#34;(!) {self._model}: Tried to enable frequency lock, but &#34;
                    f&#34;frequency lock was already enabled&#34;
                )
                return
        # (Sufficient to disable for only one of the channels)
        cmd = f&#34;SOURCE{use_channel}:FREQuency:CONCurrent {state}&#34;
        msg = f&#34;turn frequency lock {state}&#34;
        self.write(cmd, custom_err_message=msg)

    def software_trig(self):
        &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
        (for bursts or modulations)&#34;&#34;&#34;
        self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)

    ## ~~~~~~~~~~~~~~~~~~~~~ CUSTOM WAVEFORM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~ ##

    def get_waveform_catalogue(self) -&gt; List[str]:
        &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

        Returns
        -------
        catalogue : list
            Strings with the names of the user functions that are not empty
        &#34;&#34;&#34;
        catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
        catalogue = [wf[1:-1] for wf in catalogue]  # strip off extra quotes
        return catalogue

    def get_custom_waveform(self, memory_num: int) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

        Parameters
        ----------
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen or
            and empty array if waveform not in use
        &#34;&#34;&#34;
        # Find the wavefroms in use
        waveforms_in_use = self.get_waveform_catalogue()
        if f&#34;USER{memory_num}&#34; in waveforms_in_use:
            # Copy the waveform to edit memory
            self.write(f&#34;DATA:COPY EMEMory,USER{memory_num}&#34;)
            # Get the length of the waveform
            waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
            # Get the waveform (returns binary values)
            waveform = self._inst.query_binary_values(
                &#34;DATA:DATA? EMEMory&#34;,
                datatype=&#34;H&#34;,
                is_big_endian=True,
                container=np.ndarray,
            )
            msg = (
                f&#34;Waveform length from native length command (DATA:POINts?) &#34;
                f&#34;and the processed binary values do not match, &#34;
                f&#34;{waveform_length} and {len(waveform)} respectively&#34;
            )
            assert len(waveform) == waveform_length, msg
            return waveform
        print(f&#34;Waveform USER{memory_num} is not in use&#34;)
        return np.array([])

    def set_custom_waveform(
        self,
        waveform: np.ndarray,
        normalise: bool = True,
        memory_num: int = 0,
        verify: bool = True,
        print_progress: bool = True,
    ):
        &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
        NOTE: Will overwrite without warnings

        Parameters
        ----------
        waveform : ndarray
            Either unnormalised arbitrary waveform (then use `normalise=True`),
            or ints spanning the resolution of the function generator
        normalise : bool
            Choose whether to normalise the waveform to ints over the
            resolution span of the function generator
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to copy to
        verify : bool, default `True`
            Verify that the waveform has been transferred and is what was sent
        print_progress : bool, default `True`

        Returns
        -------
        waveform : ndarray
            The normalised waveform transferred

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length or value range
        RuntimeError
            If the waveform transferred to the instrument is of a different
            length than the waveform supplied
        &#34;&#34;&#34;
        if not 0 &lt;= memory_num &lt;= self._max_waveform_memory_user_locations:
            raise ValueError(
                f&#34;The memory location {memory_num} is not a valid &#34;
                &#34;memory location for this model&#34;
            )
        # Check if waveform data is suitable
        if print_progress:
            print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
        self._check_arb_waveform_length(waveform)
        try:
            self._check_arb_waveform_type_and_range(waveform)
        except ValueError as err:
            if print_progress:
                print(f&#34;\n  {err}&#34;)
                print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
            waveform = self._normalise_to_waveform(waveform)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
        # Transfer waveform
        self._inst.write_binary_values(
            &#34;DATA:DATA EMEMory,&#34;, waveform, datatype=&#34;H&#34;, is_big_endian=True
        )
        # Check for errors and check lengths are matching
        transfer_error = self.get_error()
        emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
        if emem_wf_length == &#34;&#34; or not int(emem_wf_length) == len(waveform):
            msg = (
                f&#34;Waveform in temporary EMEMory has a length of {emem_wf_length}&#34;
                f&#34;, not of the same length as the waveform ({len(waveform)}).&#34;
                f&#34;\nError from the instrument: {transfer_error}&#34;
            )
            raise RuntimeError(msg)
        if print_progress:
            print(&#34;ok&#34;)
            print(f&#34;Copy waveform to USER{memory_num}..&#34;, end=&#34; &#34;)
        self.write(f&#34;DATA:COPY USER{memory_num},EMEMory&#34;)
        if print_progress:
            print(&#34;ok&#34;)
        if verify:
            if print_progress:
                print(f&#34;Verify waveform USER{memory_num}..&#34;)
            if f&#34;USER{memory_num}&#34; in self.get_waveform_catalogue():
                verif = self._verify_waveform(
                    waveform,
                    memory_num,
                    normalise=normalise,
                    print_result=print_progress,
                )
                if not verif[0]:
                    raise RuntimeError(
                        f&#34;USER{memory_num} does not contain the waveform&#34;
                    )
            else:
                raise RuntimeError(f&#34;USER{memory_num} is empty&#34;)
        return waveform

    def _normalise_to_waveform(self, shape: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Normalise a shape of any discretisation and range to a waveform that
        can be transmitted to the function generator

        .. note::
            If you are transferring a flat/constant waveform, do not use this
            normaisation function. Transfer a waveform like
            `int(self._arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)`
            without normalising for a well behaved flat function.

        Parameters
        ----------
        shape : array_like
            Array to be transformed to waveform, can be ints or floats,
            any normalisation or discretisation

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        self._check_arb_waveform_length(shape)
        # Normalise
        waveform = shape - np.min(shape)
        normalisation_factor = np.max(waveform)
        waveform = waveform / normalisation_factor * self._arbitrary_waveform_resolution
        return waveform.astype(np.uint16)

    def _verify_waveform(
        self,
        waveform: np.ndarray,
        memory_num: int,
        normalise: bool = True,
        print_result: bool = True,
    ) -&gt; Tuple[bool, np.ndarray, list]:
        &#34;&#34;&#34;Compare a waveform in user memory to argument waveform

        Parameters
        ----------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with
        normalise : bool, default `True`
            Normalise test waveform

        Returns
        -------
        bool
            Boolean according to equal/not equal
        instrument_waveform
            The waveform on the instrument
        list or `None`
            List of the indices where the waveforms are not equal or `None` if
            the waveforms were of different lengths
        &#34;&#34;&#34;
        if normalise:  # make sure test waveform is normalised
            waveform = self._normalise_to_waveform(waveform)
        # Get the waveform on the instrument
        instrument_waveform = self.get_custom_waveform(memory_num)
        # Compare lengths
        len_inst_wav, len_wav = len(instrument_waveform), len(waveform)
        if not len_inst_wav == len_wav:
            if print_result:
                print(
                    f&#34;The waveform in USER{memory_num} and the compared &#34;
                    f&#34;waveform are not of same length (instrument &#34;
                    f&#34;{len_inst_wav} vs {len_wav})&#34;
                )
            return False, instrument_waveform, None
        # Compare each element
        not_equal = []
        for i in range(len_wav):
            if not instrument_waveform[i] == waveform[i]:
                not_equal.append(i)
        # Return depending of whether list is empty or not
        if not not_equal:  # if list is empty
            if print_result:
                print(
                    f&#34;The waveform in USER{memory_num} and the compared &#34;
                    f&#34;waveform are equal&#34;
                )
            return True, instrument_waveform, not_equal
        if print_result:
            print(
                f&#34;The waveform in USER{memory_num} and the compared &#34;
                f&#34;waveform are NOT equal&#34;
            )
        return False, instrument_waveform, not_equal

    def _check_arb_waveform_length(self, waveform: np.ndarray):
        &#34;&#34;&#34;Checks if waveform is within the acceptable length

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length
        &#34;&#34;&#34;
        if (len(waveform) &lt; self._arbitrary_waveform_length[0]) or (
            len(waveform) &gt; self._arbitrary_waveform_length[1]
        ):
            msg = (
                &#34;The waveform is of length {}, which is not within the &#34;
                &#34;acceptable length {} &lt; len &lt; {}&#34;
                &#34;&#34;.format(len(waveform), *self._arbitrary_waveform_length)
            )
            raise ValueError(msg)

    def _check_arb_waveform_type_and_range(self, waveform: np.ndarray):
        &#34;&#34;&#34;Checks if waveform is of int/np.int32 type and within the resolution
        of the function generator

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform values are not int, np.uint16 or np.int32, or the
            values are not within the permitted range
        &#34;&#34;&#34;
        for value in waveform:
            if not isinstance(value, (int, np.uint16, np.int32)):
                raise ValueError(
                    &#34;The waveform contains values that are not&#34;
                    &#34;int, np.uint16 or np.int32&#34;
                )
            if (value &lt; 0) or (value &gt; self._arbitrary_waveform_resolution):
                raise ValueError(
                    f&#34;The waveform contains values out of range &#34;
                    f&#34;({value} is not within the resolution &#34;
                    f&#34;[0, {self._arbitrary_waveform_resolution}])&#34;
                )


## ~~~~~~~~~~~~~~~~~~~~~~~ CHANNEL CLASS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##


class FuncGenChannel:
    &#34;&#34;&#34;Class for controlling a channel on a function generator object

    Parameters
    ----------
    fgen : `FuncGen`
        The function generator object
    channel : {1, 2}
        The channel to be controlled
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)

    Attributes
    ----------
    _fgen : `FuncGen`
        The function generator object for which the channel exists
    _channel : {1, 2}
        The number of the channel this object is addressing
    _source : str
        &#34;SOURce{i}:&#34; where {i} is the channel number
    &#34;&#34;&#34;

    _state_to_str = {&#34;1&#34;: &#34;ON&#34;, &#34;0&#34;: &#34;OFF&#34;, 1: &#34;ON&#34;, 0: &#34;OFF&#34;}
    &#34;&#34;&#34;Dictionary for converting output states to &#34;ON&#34; and &#34;OFF&#34; &#34;&#34;&#34;

    def __init__(self, fgen: FuncGen, channel: int, impedance: str):
        self._fgen = fgen
        self._channel = channel
        self._source = f&#34;SOURce{channel}:&#34;
        self.impedance = impedance
        &#34;&#34;&#34;{&#34;50ohm&#34;, &#34;highZ&#34;}: Determines voltage limits associated with high
        impedance (whether the instrument is using 50ohm or high Z cannot be
        controlled through VISA)&#34;&#34;&#34;
        # Adopt limits dictionary from instrument
        self.channel_limits = copy.deepcopy(self._fgen.instrument_limits)
        &#34;&#34;&#34;Channel limits for the individual channel, same form as
        `FuncGen.instrument_limits`&#34;&#34;&#34;

    def _impedance_dependent_limit(self, limit_type: str) -&gt; bool:
        &#34;&#34;&#34;Check if the limit type is impedance dependent (voltages) or
        not (frequency)

        Returns
        -------
        bool
            `True` if the limit is impedance dependent
        &#34;&#34;&#34;
        try:  # to access the key &#34;min&#34; to check if impedance must be selected
            _ = self.channel_limits[limit_type][0][&#34;min&#34;]
            return False
        except KeyError:  # if the key does not exist
            # The impedance must be selected
            return True

    def set_stricter_limits(self):
        &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
        through a series of prompts&#34;&#34;&#34;
        print(f&#34;Set stricter voltage and frequency limits for channel {self._channel}&#34;)
        print(&#34;Use enter only to leave a limit unchanged.&#34;)
        # Go through the different limits in the instrument_limits dict
        for limit_type, (inst_limit_dict, unit) in self._fgen.instrument_limits.items():
            use_impedance = self._impedance_dependent_limit(limit_type)
            print(f&#34;Set {limit_type} in {unit}&#34;, end=&#34; &#34;)
            if use_impedance:
                inst_limit_dict = inst_limit_dict[self.impedance]
                print(f&#34;[{self.impedance} impedance limit]&#34;)
            else:
                print(&#34;&#34;)  # get new line
            # Go through the min and max for the limit type
            for key, inst_value in inst_limit_dict.items():
                # prompt for new value
                new_value = input(f&#34;  {key} (instrument limit {inst_value}{unit}): &#34;)
                if new_value == &#34;&#34;:
                    # Do not change if empty
                    print(&#34;\tLimit not changed&#34;)
                else:
                    try:  # to convert to float
                        new_value = float(new_value)
                    except ValueError:
                        print(
                            f&#34;\tLimit unchanged: Could not convert &#39;{new_value}&#39; &#34;
                            f&#34;to float&#34;
                        )
                        continue  # to next item in dict
                    # Set the new limit
                    self.set_limit(limit_type, key, new_value, verbose=True)

    def set_limit(
        self, limit_type: str, bound: str, new_value: float, verbose: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
        self consistent (max larger than min)

        Parameterers
        ------------
        limit_type : str
            The name of the limit in the channel_limits dictionary
        bound : {&#34;min&#34;, &#34;max&#34;}
            Specifies if it is the max or the min limit that is to be set
        new_value : float
            The new value to be used for the limit
        verbose : bool
            Print confirmation that the limit was set or reason for why the
            limit was not set

        Returns
        -------
        bool
            `True` if new limit set, `False` otherwise
        &#34;&#34;&#34;
        # Short hand references
        inst_limit_dict = self._fgen.instrument_limits[limit_type]
        channel_limit_dict = self.channel_limits[limit_type]
        # Find the instrument limit and unit
        use_impedance = self._impedance_dependent_limit(limit_type)
        if use_impedance:
            inst_value = inst_limit_dict[0][self.impedance][bound]
        else:
            inst_value = inst_limit_dict[0][bound]
        unit = inst_limit_dict[1]
        # Check that the new value is within the intrument limits
        acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
        if use_impedance:
            current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
        else:
            current_min = channel_limit_dict[0][&#34;min&#34;]
        larger_than_min = new_value &gt; current_min
        acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
        if acceptable_min or acceptable_max:  # within the limits
            # Set the new channel_limit, using the impedance depending on the
            # limit type. Beware that the shorthand cannot be used, as this
            # only changes the shorthand not the dictionary itself
            if use_impedance:
                self.channel_limits[limit_type][0][self.impedance][bound] = new_value
            else:
                self.channel_limits[limit_type][0][bound] = new_value
            if verbose:
                print(f&#34;\tNew limit set {new_value}{unit}&#34;)
            return True
        if verbose:  # print description of why the limit was not set
            if larger_than_min:
                reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
                print(
                    f&#34;\tNew limit NOT set: {new_value}{unit} is {reason} than &#34;
                    f&#34;the instrument limit ({inst_value}{unit})&#34;
                )
            else:
                print(
                    f&#34;\tNew limit NOT set: {new_value}{unit} is smaller than the &#34;
                    f&#34;current set minimum ({current_min}{unit})&#34;
                )
        return False

    # Get currently used parameters from function generator
    def get_output_state(self) -&gt; int:
        &#34;&#34;&#34;Returns 0 for &#34;OFF&#34;, 1 for &#34;ON&#34; &#34;&#34;&#34;
        return int(self._fgen.query(f&#34;OUTPut{self._channel}:STATe?&#34;))

    def get_function(self) -&gt; str:
        &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
        return self._fgen.query(f&#34;{self._source}FUNCtion:SHAPe?&#34;)

    def get_amplitude(self) -&gt; float:
        &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}VOLTage:AMPLitude?&#34;))

    def get_offset(self) -&gt; float:
        &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}VOLTage:OFFSet?&#34;))

    def get_frequency(self) -&gt; float:
        &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}FREQuency?&#34;))

    # Get limits set in the channel class
    def get_frequency_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
        return [self.channel_limits[&#34;frequency lims&#34;][0][key] for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_voltage_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
        return [
            self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]
        ]

    def get_amplitude_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
        return [
            self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]
        ]

    def get_settings(self) -&gt; dict:
        &#34;&#34;&#34;Get the settings for the channel

        Returns
        -------
        current_settings : dict
            Settings currently in use as a dictionary with keys output,
            function, amplitude, offset, and frequency and values tuples of
            the corresponding return and unit
        &#34;&#34;&#34;
        return {
            &#34;output&#34;: (self._state_to_str[self.get_output_state()], &#34;&#34;),
            &#34;function&#34;: (self.get_function(), &#34;&#34;),
            &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
            &#34;offset&#34;: (self.get_offset(), &#34;V&#34;),
            &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;),
        }

    def print_settings(self):
        &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
        to use the `FuncGen.print_settings` for printing both channels)
        &#34;&#34;&#34;
        settings = self.get_settings()
        longest_key = max([len(key) for key in settings.keys()])
        print(&#34;\nCurrent settings for channel {}&#34;.format(self._channel))
        print(&#34;==============================&#34;)
        for key, (val, unit) in settings.items():
            print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit, num_char=longest_key))

    def set_settings(self, settings: dict):
        &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
        set the outout to OFF before applyign the settings (and turn the
        channel ON or leave it OFF depending on the settings dict)

        Parameteres
        -----------
        settings : dict
            Settings dictionary as returned by `get_settings`: should have
            keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        # First turn off to ensure no potentially harmful
        # combination of settings
        self.set_output_state(&#34;OFF&#34;)
        # Set settings according to dictionary
        self.set_function(settings[&#34;function&#34;][0])
        self.set_amplitude(settings[&#34;amplitude&#34;][0])
        self.set_offset(settings[&#34;offset&#34;][0])
        self.set_frequency(settings[&#34;frequency&#34;][0])
        self.set_output_state(settings[&#34;output&#34;][0])

    def set_output_state(self, state: Union[int, str]):
        &#34;&#34;&#34;Enables or diables the output of the channel

        Parameters
        ----------
        state : int or str
            &#34;ON&#34; or int 1 to enable
            &#34;OFF&#34; or int 0 to disable

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        err_msg = f&#34;turn channel {self._channel} to state {state}&#34;
        self._fgen.write(
            f&#34;OUTPut{self._channel}:STATe {state}&#34;, custom_err_message=err_msg
        )
        if self._fgen.verify_param_set:
            actual_state = self.get_output_state()
            if not actual_state == state:
                msg = (
                    f&#34;Channel {self._channel} was not turned {state}, it is &#34;
                    f&#34;{self._state_to_str[actual_state]}.\n&#34;
                    f&#34;Error from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def get_output(self) -&gt; int:
        &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
        return self.get_output_state()

    def set_output(self, state: Union[int, str]):
        &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
        self.set_output_state(state)

    def set_function(self, shape: str):
        &#34;&#34;&#34;Set the function shape of the output

        Parameters
        ----------
        shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
                 USER1, ..., USER255, EMEMory, EFILe}
            &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
            AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
            OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
            Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
            BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
            Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
            Cardiac}

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        cmd = f&#34;{self._source}FUNCtion:SHAPe {shape}&#34;
        self._fgen.write(cmd, custom_err_message=f&#34;set function {shape}&#34;)
        if self._fgen.verify_param_set:
            actual_shape = self.get_function()
            if not actual_shape == shape:
                msg = (
                    f&#34;Function {shape} was not set on channel {self._channel}, &#34;
                    f&#34;it is {actual_shape}. Check that the function name is &#34;
                    f&#34;correctly spelt. Look up `set_function.__doc__` to see &#34;
                    f&#34;available shapes.\n Error from the instrument: &#34;
                    f&#34;{self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_amplitude(self, amplitude: float):
        &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

        Parameters
        ----------
        amplitude : float or {&#34;max&#34;, &#34;min&#34;}
            0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
            amplitude to the maximum or minimum limit given in `channel_limits`

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check if keyword min or max is given
        if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
            unit = &#34;&#34;  # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][
                str(amplitude).lower()
            ]
        else:
            unit = &#34;Vpp&#34;
            # Check if the given amplitude is within the current limits
            min_ampl, max_ampl = self.get_amplitude_lims()
            if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
                msg = (
                    f&#34;Could not set the amplitude {amplitude}{unit} as it &#34;
                    f&#34;is not within the amplitude limits set for the instrument &#34;
                    f&#34;[{min_ampl}, {max_ampl}]{unit}&#34;
                )
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_offset = self.get_offset()
        if (
            amplitude / 2 - current_offset &lt; min_volt
            or amplitude / 2 + current_offset &gt; max_volt
        ):
            msg = (
                f&#34;Could not set the amplitude {amplitude}{unit} as the amplitude &#34;
                f&#34;combined with the offset ({current_offset}V) will be outside the &#34;
                f&#34;absolute voltage limits [{min_volt}, {max_volt}]{unit}&#34;
            )
            raise NotSetError(msg)
        # Set the amplitude
        cmd = f&#34;{self._source}VOLTage:LEVel {amplitude}{unit}&#34;
        err_msg = f&#34;set amplitude {amplitude}{unit}&#34;
        self._fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the amplitude has been set
        if self._fgen.verify_param_set:
            actual_amplitude = self.get_amplitude()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_amplitude = amplitude * _SI_prefix_to_factor(unit)
            else:
                check_amplitude = amplitude
            if not actual_amplitude == check_amplitude:
                msg = (
                    f&#34;Amplitude {amplitude}{unit} was not set on channel &#34;
                    f&#34;{self._channel}, it is {actual_amplitude}Vpp. Check that &#34;
                    f&#34; the number is within the possible range and in the &#34;
                    f&#34;correct format.\nError from the instrument: &#34;
                    f&#34;{self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_offset(self, offset: float, unit: str = &#34;V&#34;):
        &#34;&#34;&#34;Set offset in volts (or mV, see options)

        Parameters
        ----------
        offset : float
            Unknown resolution, guessing 0.1mV or four digits resolution
        unit : {mV, V}, default V

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check that the new offset will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_amplitude = self.get_amplitude()
        offset = _SI_prefix_to_factor(unit) * offset
        if (
            current_amplitude / 2 - offset &lt; min_volt
            or current_amplitude / 2 + offset &gt; max_volt
        ):
            msg = (
                f&#34;Could not set the offset {offset}V as the offset combined &#34;
                f&#34;with the amplitude ({current_amplitude}V) will be outside &#34;
                f&#34;the absolute voltage limits [{min_volt}, {max_volt}]V&#34;
            )
            raise NotSetError(msg)
        # Set the offset
        cmd = f&#34;{self._source}VOLTage:LEVel:OFFSet {offset}{unit}&#34;
        err_msg = f&#34;set offset {offset}{unit}&#34;
        self._fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the offset has been set
        if self._fgen.verify_param_set:
            actual_offset = self.get_offset()
            # Multiply with the appropriate factor according to SI prefix
            check_offset = offset * _SI_prefix_to_factor(unit)
            if not actual_offset == check_offset:
                msg = (
                    f&#34;Offset {offset}{unit} was not set on channel &#34;
                    f&#34;{self._channel}, it is {actual_offset}V. Check that the &#34;
                    f&#34;number is within the possible range and in the correct &#34;
                    f&#34;format.\nError from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_frequency(self, freq: float, unit: str = &#34;Hz&#34;):
        &#34;&#34;&#34;Set the frequency in Hertz (or mHz, kHz, MHz, see options)

        Parameters
        ----------
        freq : float
            The resolution is 1 μHz or 12 digits.
        unit : {mHz, Hz, kHz, MHz}, default Hz

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]:  # handle min and max keywords
            unit = &#34;&#34;  # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
        else:
            # Check if the given frequency is within the current limits
            min_freq, max_freq = self.get_frequency_lims()
            freq = _SI_prefix_to_factor(unit) * freq
            if freq &lt; min_freq or freq &gt; max_freq:
                msg = (
                    f&#34;Could not set the frequency {freq}Hz as it is not &#34;
                    f&#34;within the frequency limits set for the instrument &#34;
                    f&#34;[{min_freq}, {max_freq}]Hz&#34;
                )
                raise NotSetError(msg)
        # Set the frequency
        self._fgen.write(
            f&#34;{self._source}FREQuency:FIXed {freq}{unit}&#34;,
            custom_err_message=f&#34;set frequency {freq}{unit}&#34;,
        )
        # Verify that the amplitude has been set
        if self._fgen.verify_param_set:
            actual_freq = self.get_frequency()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_freq = freq * _SI_prefix_to_factor(unit)
            else:
                check_freq = freq
            if not actual_freq == check_freq:
                msg = (
                    f&#34;Frequency {freq}{unit} was not set on channel {self._channel}&#34;
                    f&#34;, it is {actual_freq}Hz. Check that the number is within &#34;
                    f&#34;the possible range and in the correct format.\nError &#34;
                    f&#34;from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EXAMPLES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##


def example_basic_control(address: str):
    &#34;&#34;&#34;Example showing how to connect, and the most basic control of the
    instrument parameters&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_basic_control.__doc__)
    with FuncGen(address) as fgen:
        fgen.ch1.set_function(&#34;SIN&#34;)
        fgen.ch1.set_frequency(25, unit=&#34;Hz&#34;)
        fgen.ch1.set_offset(50, unit=&#34;mV&#34;)
        fgen.ch1.set_amplitude(0.002)
        fgen.ch1.set_output(&#34;ON&#34;)
        fgen.ch2.set_output(&#34;OFF&#34;)
        # Alternatively fgen.ch1.print_settings() to show from one channel only
        fgen.print_settings()


def example_change_settings(address: str):
    &#34;&#34;&#34;Example showing how to get the current settings of the instrument,
    store them, change a setting and then restore the initial settings&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_change_settings.__doc__)
    with FuncGen(address) as fgen:
        fgen.print_settings()
        print(&#34;Saving these settings..&#34;)
        settings = fgen.get_settings()
        print(&#34;Change to 1Vpp amplitude for channel 1..&#34;)
        fgen.ch1.set_amplitude(1)
        fgen.print_settings()
        print(&#34;Reset back to initial settings..&#34;)
        fgen.set_settings(settings)
        fgen.print_settings()


def example_lock_frequencies(address: str):
    &#34;&#34;&#34;Example showing the frequency being set to 10Hz and then the frequency
    lock enabled, using the frequency at ch1 as the common frequency&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_lock_frequencies.__doc__)
    with FuncGen(address, verbose=False) as fgen:
        fgen.ch1.set_frequency(10)
        fgen.set_frequency_lock(&#34;ON&#34;, use_channel=1)


def example_changing_limits(address: str):
    &#34;&#34;&#34;Example showing how limits can be read and changed&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_changing_limits.__doc__)
    with FuncGen(address) as fgen:
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Change the lower limit to 2Hz..&#34;)
        fgen.ch1.set_limit(&#34;frequency lims&#34;, &#34;min&#34;, 2)
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Try to set ch1 frequency to 1Hz..&#34;)
        try:
            fgen.ch1.set_frequency(1)
        except NotSetError as err:
            print(err)


def example_set_and_use_custom_waveform(
    fgen: FuncGen = None,
    address: str = None,
    channel: int = 1,
    plot_signal: bool = True,
):
    &#34;&#34;&#34;Example showing a waveform being created, transferred to the instrument,
    and applied to a channel&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_set_and_use_custom_waveform.__doc__)
    # Create a signal
    x = np.linspace(0, 4 * np.pi, 8000)
    signal = np.sin(x) + x / 5
    if plot_signal:  # plot the signal for visual control
        import matplotlib.pyplot as plt

        plt.plot(signal)
        plt.show()
    # Create initialise fgen if it was not supplied
    if fgen is None:
        fgen = FuncGen(address)
        close_fgen = True  # specify that it should be closed at end of function
    else:
        close_fgen = False  # do not close the supplied fgen at end
    print(&#34;Current waveform catalogue&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(f&#34;  {i}: {wav}&#34;)
    # Transfer the waveform
    fgen.set_custom_waveform(signal, memory_num=5, verify=True)
    print(&#34;New waveform catalogue:&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(f&#34;  {i}: {wav}&#34;)
    print(f&#34;Set new wavefrom to channel {channel}..&#34;, end=&#34; &#34;)
    fgen.channels[channel - 1].set_output_state(&#34;OFF&#34;)
    fgen.channels[channel - 1].set_function(&#34;USER5&#34;)
    print(&#34;ok&#34;)
    # Print current settings
    fgen.get_settings()
    if close_fgen:
        fgen.close()


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN FUNCTION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

if __name__ == &#34;__main__&#34;:
    example_basic_control(_VISA_ADDRESS)
    example_change_settings(_VISA_ADDRESS)
    example_lock_frequencies(_VISA_ADDRESS)
    example_changing_limits(_VISA_ADDRESS)
    with FuncGen(_VISA_ADDRESS) as fgen:
        example_set_and_use_custom_waveform(fgen)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tektronix_func_gen.example_basic_control"><code class="name flex">
<span>def <span class="ident">example_basic_control</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Example showing how to connect, and the most basic control of the
instrument parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_basic_control(address: str):
    &#34;&#34;&#34;Example showing how to connect, and the most basic control of the
    instrument parameters&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_basic_control.__doc__)
    with FuncGen(address) as fgen:
        fgen.ch1.set_function(&#34;SIN&#34;)
        fgen.ch1.set_frequency(25, unit=&#34;Hz&#34;)
        fgen.ch1.set_offset(50, unit=&#34;mV&#34;)
        fgen.ch1.set_amplitude(0.002)
        fgen.ch1.set_output(&#34;ON&#34;)
        fgen.ch2.set_output(&#34;OFF&#34;)
        # Alternatively fgen.ch1.print_settings() to show from one channel only
        fgen.print_settings()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_change_settings"><code class="name flex">
<span>def <span class="ident">example_change_settings</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Example showing how to get the current settings of the instrument,
store them, change a setting and then restore the initial settings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_change_settings(address: str):
    &#34;&#34;&#34;Example showing how to get the current settings of the instrument,
    store them, change a setting and then restore the initial settings&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_change_settings.__doc__)
    with FuncGen(address) as fgen:
        fgen.print_settings()
        print(&#34;Saving these settings..&#34;)
        settings = fgen.get_settings()
        print(&#34;Change to 1Vpp amplitude for channel 1..&#34;)
        fgen.ch1.set_amplitude(1)
        fgen.print_settings()
        print(&#34;Reset back to initial settings..&#34;)
        fgen.set_settings(settings)
        fgen.print_settings()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_changing_limits"><code class="name flex">
<span>def <span class="ident">example_changing_limits</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Example showing how limits can be read and changed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_changing_limits(address: str):
    &#34;&#34;&#34;Example showing how limits can be read and changed&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_changing_limits.__doc__)
    with FuncGen(address) as fgen:
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Change the lower limit to 2Hz..&#34;)
        fgen.ch1.set_limit(&#34;frequency lims&#34;, &#34;min&#34;, 2)
        lims = fgen.ch1.get_frequency_lims()
        print(&#34;Channel 1 frequency limits: {}&#34;.format(lims))
        print(&#34;Try to set ch1 frequency to 1Hz..&#34;)
        try:
            fgen.ch1.set_frequency(1)
        except NotSetError as err:
            print(err)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_lock_frequencies"><code class="name flex">
<span>def <span class="ident">example_lock_frequencies</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Example showing the frequency being set to 10Hz and then the frequency
lock enabled, using the frequency at ch1 as the common frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_lock_frequencies(address: str):
    &#34;&#34;&#34;Example showing the frequency being set to 10Hz and then the frequency
    lock enabled, using the frequency at ch1 as the common frequency&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_lock_frequencies.__doc__)
    with FuncGen(address, verbose=False) as fgen:
        fgen.ch1.set_frequency(10)
        fgen.set_frequency_lock(&#34;ON&#34;, use_channel=1)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.example_set_and_use_custom_waveform"><code class="name flex">
<span>def <span class="ident">example_set_and_use_custom_waveform</span></span>(<span>fgen: <a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a> = None, address: str = None, channel: int = 1, plot_signal: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Example showing a waveform being created, transferred to the instrument,
and applied to a channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def example_set_and_use_custom_waveform(
    fgen: FuncGen = None,
    address: str = None,
    channel: int = 1,
    plot_signal: bool = True,
):
    &#34;&#34;&#34;Example showing a waveform being created, transferred to the instrument,
    and applied to a channel&#34;&#34;&#34;
    print(&#34;\n\n&#34;, example_set_and_use_custom_waveform.__doc__)
    # Create a signal
    x = np.linspace(0, 4 * np.pi, 8000)
    signal = np.sin(x) + x / 5
    if plot_signal:  # plot the signal for visual control
        import matplotlib.pyplot as plt

        plt.plot(signal)
        plt.show()
    # Create initialise fgen if it was not supplied
    if fgen is None:
        fgen = FuncGen(address)
        close_fgen = True  # specify that it should be closed at end of function
    else:
        close_fgen = False  # do not close the supplied fgen at end
    print(&#34;Current waveform catalogue&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(f&#34;  {i}: {wav}&#34;)
    # Transfer the waveform
    fgen.set_custom_waveform(signal, memory_num=5, verify=True)
    print(&#34;New waveform catalogue:&#34;)
    for i, wav in enumerate(fgen.get_waveform_catalogue()):
        print(f&#34;  {i}: {wav}&#34;)
    print(f&#34;Set new wavefrom to channel {channel}..&#34;, end=&#34; &#34;)
    fgen.channels[channel - 1].set_output_state(&#34;OFF&#34;)
    fgen.channels[channel - 1].set_function(&#34;USER5&#34;)
    print(&#34;ok&#34;)
    # Print current settings
    fgen.get_settings()
    if close_fgen:
        fgen.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tektronix_func_gen.FuncGen"><code class="flex name class">
<span>class <span class="ident">FuncGen</span></span>
<span>(</span><span>visa_address: str, impedance: Tuple[str, str] = ('highZ', 'highZ'), timeout: int = 1000, verify_param_set: bool = False, override_compatibility: str = '', verbose: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for interacting with Tektronix function generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>visa_address</code></strong> :&ensp;<code>str</code></dt>
<dd>VISA address of the insrument</dd>
<dt><strong><code>impedance</code></strong> :&ensp;<code>tuple</code> of <code>{"highZ", "50ohm"}</code>, default <code>("highZ",)*2</code></dt>
<dd>Determines voltage limits associated with high impedance (whether the
instrument is using 50ohm or high Z cannot be controlled through VISA).
For example <code>("highZ", "50ohm")</code> for to use high Z for ch1 and
50 ohm for ch2</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, default <code>1000</code></dt>
<dd>Timeout in milliseconds of instrument connection</dd>
<dt><strong><code>verify_param_set</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Verify that a value is successfully set after executing a set function</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Choose whether to print information such as model upon connecting etc</dd>
<dt><strong><code>override_compatibility</code></strong> :&ensp;<code>str</code>, default <code>""</code></dt>
<dd>If the instrument limits for the model connected to are not known
<code><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError">NotCompatibleError</a></code> will be raised. To override and use either of
AFG1022, AFG1062, or AFG3022 limits, use their respecive model names as
argument. Note that this might lead to unexpected behaviour for custom
waveforms and 'MIN'/'MAX' keywords.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_visa_address</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA address of the instrument</dd>
<dt><strong><code>_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Comma separated string with maker, model, serial and firmware of
the instrument</dd>
<dt><strong><code>_inst</code></strong> :&ensp;<code>pyvisa.resources.Resource</code></dt>
<dd>The PyVISA resource</dd>
<dt><strong><code>_arbitrary_waveform_length</code></strong> :&ensp;<code>list</code></dt>
<dd>The permitted minimum and maximum length of an arbitrary waveform,
e.g. [2, 8192]</dd>
<dt><strong><code>_arbitrary_waveform_resolution</code></strong> :&ensp;<code>int</code></dt>
<dd>The vertical resolution of the arbitrary waveform, for instance 14 bit
=&gt; 2**14-1 = 16383</dd>
<dt><strong><code>_max_waveform_memory_user_locations</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the last user memory location available</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>pyvisa.Error</code></dt>
<dd>If the supplied VISA address cannot be connected to</dd>
<dt><code><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError">NotCompatibleError</a></code></dt>
<dd>If the instrument limits for the model connected to are not known
(Call the class with <code>override_compatibility=True</code> to override and
use AFG1022 limits)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncGen:
    &#34;&#34;&#34;Class for interacting with Tektronix function generator

    Parameters
    ----------
    visa_address : str
        VISA address of the insrument
    impedance : tuple of {&#34;highZ&#34;, &#34;50ohm&#34;}, default (&#34;highZ&#34;,)*2
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA).
        For example `(&#34;highZ&#34;, &#34;50ohm&#34;)` for to use high Z for ch1 and
        50 ohm for ch2
    timeout : int, default 1000
        Timeout in milliseconds of instrument connection
    verify_param_set : bool, default False
        Verify that a value is successfully set after executing a set function
    verbose : bool, default `True`
        Choose whether to print information such as model upon connecting etc
    override_compatibility : str, default `&#34;&#34;`
        If the instrument limits for the model connected to are not known
        `NotCompatibleError` will be raised. To override and use either of
        AFG1022, AFG1062, or AFG3022 limits, use their respecive model names as
        argument. Note that this might lead to unexpected behaviour for custom
        waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.

    Attributes
    ----------
    _visa_address : str
        The VISA address of the instrument
    _id : str
        Comma separated string with maker, model, serial and firmware of
        the instrument
    _inst : `pyvisa.resources.Resource`
        The PyVISA resource
    _arbitrary_waveform_length : list
        The permitted minimum and maximum length of an arbitrary waveform,
        e.g. [2, 8192]
    _arbitrary_waveform_resolution : int
        The vertical resolution of the arbitrary waveform, for instance 14 bit
        =&gt; 2**14-1 = 16383
    _max_waveform_memory_user_locations : int
        The number of the last user memory location available

    Raises
    ------
    pyvisa.Error
        If the supplied VISA address cannot be connected to
    NotCompatibleError
        If the instrument limits for the model connected to are not known
        (Call the class with `override_compatibility=True` to override and
        use AFG1022 limits)
    &#34;&#34;&#34;

    _is_connected = False
    &#34;&#34;&#34;bool: Keeping track of whether the PYVISA connection has been established&#34;&#34;&#34;

    instrument_limits = {}
    &#34;&#34;&#34;dict: Contains the following keys with subdictionaries

        - `frequency lims`
          Containing the frequency limits for the instrument where the keys
          &#34;min&#34; and &#34;max&#34; have values corresponding to minimum and maximum
          frequencies in Hz
        - `voltage lims`
          Contains the maximum absolute voltage the instrument can output
          for the keys &#34;50ohm&#34; and &#34;highZ&#34; according to the impedance setting
        - `amplitude lims`
          Contains the smallest and largest possible amplitudes where the
          keys &#34;50ohm&#34; and &#34;highZ&#34; will have subdictionaries with keys
          &#34;min&#34; and &#34;max&#34;
    &#34;&#34;&#34;

    def __init__(
        self,
        visa_address: str,
        impedance: Tuple[str, str] = (&#34;highZ&#34;,) * 2,
        timeout: int = 1000,
        verify_param_set: bool = False,
        override_compatibility: str = &#34;&#34;,
        verbose: bool = True,
    ):
        self._override_compat = override_compatibility
        self._visa_address = visa_address
        self.verify_param_set = verify_param_set
        &#34;&#34;&#34;bool:  Verify that a value is successfully set after executing a set function&#34;&#34;&#34;
        self.verbose = verbose
        &#34;&#34;&#34;bool: Choose whether to print information such as model upon connecting etc&#34;&#34;&#34;
        self.open(visa_address, timeout)
        self._initialise_model_properties()
        self.channels = (
            self._spawn_channel(1, impedance[0]),
            self._spawn_channel(2, impedance[1]),
        )
        &#34;&#34;&#34;tuple of `FuncGenChannel`: Objects to control the channels&#34;&#34;&#34;
        self.ch1 = self.channels[0]
        &#34;&#34;&#34;`FuncGenChannel`: Short hand for `channels[0]` Object to control channel 1&#34;&#34;&#34;
        self.ch2 = self.channels[1]
        &#34;&#34;&#34;`FuncGenChannel`: Short hand for `channels[1]` Object to control channel 2&#34;&#34;&#34;

    def __enter__(self, **kwargs):
        # The kwargs will be passed on to __init__
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        self.close()

    def open(self, visa_address: str, timeout: int):
        try:
            rm = pyvisa.ResourceManager()
            self._inst = rm.open_resource(visa_address)
        except pyvisa.Error:
            print(f&#34;\nVisaError: Could not connect to &#39;{visa_address}&#39;&#34;)
            raise
        self._is_connected = True
        self.timeout = timeout
        # Clear all the event registers and queues used in the instrument
        # status and event reporting system
        self.write(&#34;*CLS&#34;)
        # Get information about the connected device
        self._id = self.query(&#34;*IDN?&#34;)
        # Second query might be needed due to unknown reason
        if self._id == &#34;&#34;:
            self._id = self.query(&#34;*IDN?&#34;)
        self._maker, self._model, self._serial = self._id.split(&#34;,&#34;)[:3]
        if self.verbose:
            print(
                f&#34;Connected to {self._maker} model {self._model}, &#34;
                f&#34;serial {self._serial}&#34;
            )

    def close(self):
        &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
        if self._is_connected:
            self._inst.close()
            self._is_connected = False

    @property
    def timeout(self) -&gt; int:
        &#34;&#34;&#34;The timeout of the PYVISA connection in milliseconds&#34;&#34;&#34;
        return self._inst.timeout

    @timeout.setter
    def timeout(self, ms: int):
        self._inst.timeout = ms

    def _initialise_model_properties(self):
        &#34;&#34;&#34;Initialises the limits of what the instrument can handle according
        to the instrument model

        Raises
        ------
        NotCompatibleError
            If the connected model is not necessarily compatible with this
            package, slimits are not known.
        &#34;&#34;&#34;
        if np.any([&#34;AFG1022&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 8192]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 255
        elif np.any([&#34;AFG1062&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 60e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.001, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.002, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 1e6]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 31
        elif np.any([&#34;AFG3022&#34; in a for a in [self._model, self._override_compat]]):
            self.instrument_limits = {
                &#34;frequency lims&#34;: ({&#34;min&#34;: 1e-6, &#34;max&#34;: 25e6}, &#34;Hz&#34;),
                &#34;voltage lims&#34;: (
                    {&#34;50ohm&#34;: {&#34;min&#34;: -5, &#34;max&#34;: 5}, &#34;highZ&#34;: {&#34;min&#34;: -10, &#34;max&#34;: 10}},
                    &#34;V&#34;,
                ),
                &#34;amplitude lims&#34;: (
                    {
                        &#34;50ohm&#34;: {&#34;min&#34;: 0.01, &#34;max&#34;: 10},
                        &#34;highZ&#34;: {&#34;min&#34;: 0.02, &#34;max&#34;: 20},
                    },
                    &#34;Vpp&#34;,
                ),
            }
            self._arbitrary_waveform_length = [2, 65536]  # min length, max length
            self._arbitrary_waveform_resolution = 16383  # 14 bit
            self._max_waveform_memory_user_locations = 4
        else:
            msg = (
                f&#34;Model {self._model} might not be fully supported!\n&#34;
                &#34;  The module has been tested with AFG1022, AFG1062, and AFG3022.\n&#34;
                &#34;  To initiate and use the module as any of these, call the\n&#34;
                &#34;  class with for instance `override_compatibility=&#39;AFG1022&#39;`\n&#34;
                &#34;  Note that this might lead to unexpected behaviour\n&#34;
                &#34;  for custom waveforms and &#39;MIN&#39;/&#39;MAX&#39; keywords.&#34;
            )
            raise NotCompatibleError(msg)

    def write(self, command: str, custom_err_message: str = None) -&gt; int:
        &#34;&#34;&#34;Write a VISA command to the instrument

        Parameters
        ----------
        command : str
            The VISA command to be written to the instrument
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        bytes : int
            Number of bytes tranferred

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        num_bytes = self._inst.write(command)
        self._check_pyvisa_status(command, custom_err_message=custom_err_message)
        return num_bytes

    def query(self, command: str, custom_err_message: str = None) -&gt; str:
        &#34;&#34;&#34;Query the instrument

        Parameters
        ----------
        command : str
            The VISA query command
        custom_err_message : str, default `None`
            When `None`, the RuntimeError message is &#34;Writing/querying command
            {command} failed: pyvisa returned StatusCode ..&#34;.
            Otherwise, if a message is supplied &#34;Could not {message}:
            pyvisa returned StatusCode ..&#34;

        Returns
        -------
        str
            The instrument&#39;s response

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        response = self._inst.query(command).strip()
        self._check_pyvisa_status(command, custom_err_message=custom_err_message)
        return response

    def _check_pyvisa_status(self, command: str, custom_err_message: str = None):
        &#34;&#34;&#34;Check the last status code of PyVISA

        Parameters
        ----------
        command : str
            The VISA write/query command

        Returns
        -------
        status : pyvisa.constants.StatusCode
            Return value of the library call

        Raises
        ------
        RuntimeError
            If status returned by PyVISA write command is not
            `pyvisa.constants.StatusCode.success`
        &#34;&#34;&#34;
        status = self._inst.last_status
        if not status == pyvisa.constants.StatusCode.success:
            if custom_err_message is not None:
                msg = (
                    f&#34;Could not {custom_err_message}: pyvisa returned &#34;
                    f&#34;StatusCode {status} ({str(status)})&#34;
                )
                raise RuntimeError(msg)
            msg = (
                f&#34;Writing/querying command {command} failed: pyvisa returned &#34;
                f&#34;StatusCode {status} ({str(status)})&#34;
            )
            raise RuntimeError(msg)
        return status

    def get_error(self) -&gt; str:
        &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

        Returns
        -------
        str
            Error/event number, description of error/event
        &#34;&#34;&#34;
        return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)

    def _spawn_channel(self, channel: int, impedance: str) -&gt; &#34;FuncGenChannel&#34;:
        &#34;&#34;&#34;Wrapper function to create a `FuncGenChannel` object for
        a channel -- see the class docstring&#34;&#34;&#34;
        return FuncGenChannel(self, channel, impedance)

    def get_settings(self) -&gt; List[dict]:
        &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

        Returns
        -------
        settings : list of dicts
            [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
            with keys output, function, amplitude, offset, and frequency with
            corresponding values
        &#34;&#34;&#34;
        return [ch.get_settings() for ch in self.channels]

    def print_settings(self):
        &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
        settings = self.get_settings()
        # Find the necessary padding for the table columns
        # by evaluating the maximum length of the entries
        key_padding = max([len(key) for key in settings[0].keys()])
        ch_paddings = [
            max([len(str(val[0])) for val in ch_settings.values()])
            for ch_settings in settings
        ]
        padding = [key_padding] + ch_paddings
        print(f&#34;\nCurrent settings for {self._maker} {self._model} {self._serial}\n&#34;)
        row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
        table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;, &#34;Unit&#34;, padd=padding)
        print(table_header)
        print(&#34;=&#34; * len(table_header))
        for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(
            settings[0].items(), settings[1].items()
        ):
            print(
                row_format.format(ch1key, str(ch1val), str(ch2val), unit, padd=padding)
            )

    def set_settings(self, settings: List[dict]):
        &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

        (Each channel is turned off before applying the changes to avoid
        potentially harmful combinations)

        Parameteres
        -----------
        settings : list of dicts
            List of settings dictionaries as returned by `get_settings`, first
            entry for channel 1, second for channel 2. The dictionaries should
            have keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        for ch, s in zip(self.channels, settings):
            ch.set_settings(s)

    def syncronise_waveforms(self):
        &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

        Note: Does NOT enable the frequency lock that can be enabled on the
        user interface of the instrument)
        &#34;&#34;&#34;
        self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)

    def get_frequency_lock(self) -&gt; bool:
        &#34;&#34;&#34;Check if frequency lock is enabled

        Returns
        -------
        bool
            `True` if frequency lock enabled
        &#34;&#34;&#34;
        # If one is locked so is the other, so just need to check one
        return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1

    def set_frequency_lock(self, state: str, use_channel: int = 1):
        &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
        frequency and phase of their signals, also after adjustments.

        See also `FuncGen.syncronise_waveforms` for one-time sync only.

        Parameters
        ----------
        state : {&#34;ON&#34;, &#34;OFF&#34;}
            ON to enable, OFF to disable the lock
        use_channel : int, default 1
            Only relevant if turning the lock ON: The channel whose frequency
            shall be used as the common freqency
        &#34;&#34;&#34;
        if self.verbose:
            if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
                print(
                    f&#34;(!) {self._model}: Tried to disable frequency lock, but &#34;
                    f&#34;frequency lock was not enabled&#34;
                )
                return
            if state.lower() == &#34;on&#34; and self.get_frequency_lock():
                print(
                    f&#34;(!) {self._model}: Tried to enable frequency lock, but &#34;
                    f&#34;frequency lock was already enabled&#34;
                )
                return
        # (Sufficient to disable for only one of the channels)
        cmd = f&#34;SOURCE{use_channel}:FREQuency:CONCurrent {state}&#34;
        msg = f&#34;turn frequency lock {state}&#34;
        self.write(cmd, custom_err_message=msg)

    def software_trig(self):
        &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
        (for bursts or modulations)&#34;&#34;&#34;
        self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)

    ## ~~~~~~~~~~~~~~~~~~~~~ CUSTOM WAVEFORM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~ ##

    def get_waveform_catalogue(self) -&gt; List[str]:
        &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

        Returns
        -------
        catalogue : list
            Strings with the names of the user functions that are not empty
        &#34;&#34;&#34;
        catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
        catalogue = [wf[1:-1] for wf in catalogue]  # strip off extra quotes
        return catalogue

    def get_custom_waveform(self, memory_num: int) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

        Parameters
        ----------
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen or
            and empty array if waveform not in use
        &#34;&#34;&#34;
        # Find the wavefroms in use
        waveforms_in_use = self.get_waveform_catalogue()
        if f&#34;USER{memory_num}&#34; in waveforms_in_use:
            # Copy the waveform to edit memory
            self.write(f&#34;DATA:COPY EMEMory,USER{memory_num}&#34;)
            # Get the length of the waveform
            waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
            # Get the waveform (returns binary values)
            waveform = self._inst.query_binary_values(
                &#34;DATA:DATA? EMEMory&#34;,
                datatype=&#34;H&#34;,
                is_big_endian=True,
                container=np.ndarray,
            )
            msg = (
                f&#34;Waveform length from native length command (DATA:POINts?) &#34;
                f&#34;and the processed binary values do not match, &#34;
                f&#34;{waveform_length} and {len(waveform)} respectively&#34;
            )
            assert len(waveform) == waveform_length, msg
            return waveform
        print(f&#34;Waveform USER{memory_num} is not in use&#34;)
        return np.array([])

    def set_custom_waveform(
        self,
        waveform: np.ndarray,
        normalise: bool = True,
        memory_num: int = 0,
        verify: bool = True,
        print_progress: bool = True,
    ):
        &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
        NOTE: Will overwrite without warnings

        Parameters
        ----------
        waveform : ndarray
            Either unnormalised arbitrary waveform (then use `normalise=True`),
            or ints spanning the resolution of the function generator
        normalise : bool
            Choose whether to normalise the waveform to ints over the
            resolution span of the function generator
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to copy to
        verify : bool, default `True`
            Verify that the waveform has been transferred and is what was sent
        print_progress : bool, default `True`

        Returns
        -------
        waveform : ndarray
            The normalised waveform transferred

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length or value range
        RuntimeError
            If the waveform transferred to the instrument is of a different
            length than the waveform supplied
        &#34;&#34;&#34;
        if not 0 &lt;= memory_num &lt;= self._max_waveform_memory_user_locations:
            raise ValueError(
                f&#34;The memory location {memory_num} is not a valid &#34;
                &#34;memory location for this model&#34;
            )
        # Check if waveform data is suitable
        if print_progress:
            print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
        self._check_arb_waveform_length(waveform)
        try:
            self._check_arb_waveform_type_and_range(waveform)
        except ValueError as err:
            if print_progress:
                print(f&#34;\n  {err}&#34;)
                print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
            waveform = self._normalise_to_waveform(waveform)
        if print_progress:
            print(&#34;ok&#34;)
            print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
        # Transfer waveform
        self._inst.write_binary_values(
            &#34;DATA:DATA EMEMory,&#34;, waveform, datatype=&#34;H&#34;, is_big_endian=True
        )
        # Check for errors and check lengths are matching
        transfer_error = self.get_error()
        emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
        if emem_wf_length == &#34;&#34; or not int(emem_wf_length) == len(waveform):
            msg = (
                f&#34;Waveform in temporary EMEMory has a length of {emem_wf_length}&#34;
                f&#34;, not of the same length as the waveform ({len(waveform)}).&#34;
                f&#34;\nError from the instrument: {transfer_error}&#34;
            )
            raise RuntimeError(msg)
        if print_progress:
            print(&#34;ok&#34;)
            print(f&#34;Copy waveform to USER{memory_num}..&#34;, end=&#34; &#34;)
        self.write(f&#34;DATA:COPY USER{memory_num},EMEMory&#34;)
        if print_progress:
            print(&#34;ok&#34;)
        if verify:
            if print_progress:
                print(f&#34;Verify waveform USER{memory_num}..&#34;)
            if f&#34;USER{memory_num}&#34; in self.get_waveform_catalogue():
                verif = self._verify_waveform(
                    waveform,
                    memory_num,
                    normalise=normalise,
                    print_result=print_progress,
                )
                if not verif[0]:
                    raise RuntimeError(
                        f&#34;USER{memory_num} does not contain the waveform&#34;
                    )
            else:
                raise RuntimeError(f&#34;USER{memory_num} is empty&#34;)
        return waveform

    def _normalise_to_waveform(self, shape: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Normalise a shape of any discretisation and range to a waveform that
        can be transmitted to the function generator

        .. note::
            If you are transferring a flat/constant waveform, do not use this
            normaisation function. Transfer a waveform like
            `int(self._arbitrary_waveform_resolution/2)*np.ones(2).astype(np.int32)`
            without normalising for a well behaved flat function.

        Parameters
        ----------
        shape : array_like
            Array to be transformed to waveform, can be ints or floats,
            any normalisation or discretisation

        Returns
        -------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        &#34;&#34;&#34;
        # Check if waveform data is suitable
        self._check_arb_waveform_length(shape)
        # Normalise
        waveform = shape - np.min(shape)
        normalisation_factor = np.max(waveform)
        waveform = waveform / normalisation_factor * self._arbitrary_waveform_resolution
        return waveform.astype(np.uint16)

    def _verify_waveform(
        self,
        waveform: np.ndarray,
        memory_num: int,
        normalise: bool = True,
        print_result: bool = True,
    ) -&gt; Tuple[bool, np.ndarray, list]:
        &#34;&#34;&#34;Compare a waveform in user memory to argument waveform

        Parameters
        ----------
        waveform : ndarray
            Waveform as ints spanning the resolution of the function gen
        memory_num : str or int {0,...,255}, default 0
            Select which user memory to compare with
        normalise : bool, default `True`
            Normalise test waveform

        Returns
        -------
        bool
            Boolean according to equal/not equal
        instrument_waveform
            The waveform on the instrument
        list or `None`
            List of the indices where the waveforms are not equal or `None` if
            the waveforms were of different lengths
        &#34;&#34;&#34;
        if normalise:  # make sure test waveform is normalised
            waveform = self._normalise_to_waveform(waveform)
        # Get the waveform on the instrument
        instrument_waveform = self.get_custom_waveform(memory_num)
        # Compare lengths
        len_inst_wav, len_wav = len(instrument_waveform), len(waveform)
        if not len_inst_wav == len_wav:
            if print_result:
                print(
                    f&#34;The waveform in USER{memory_num} and the compared &#34;
                    f&#34;waveform are not of same length (instrument &#34;
                    f&#34;{len_inst_wav} vs {len_wav})&#34;
                )
            return False, instrument_waveform, None
        # Compare each element
        not_equal = []
        for i in range(len_wav):
            if not instrument_waveform[i] == waveform[i]:
                not_equal.append(i)
        # Return depending of whether list is empty or not
        if not not_equal:  # if list is empty
            if print_result:
                print(
                    f&#34;The waveform in USER{memory_num} and the compared &#34;
                    f&#34;waveform are equal&#34;
                )
            return True, instrument_waveform, not_equal
        if print_result:
            print(
                f&#34;The waveform in USER{memory_num} and the compared &#34;
                f&#34;waveform are NOT equal&#34;
            )
        return False, instrument_waveform, not_equal

    def _check_arb_waveform_length(self, waveform: np.ndarray):
        &#34;&#34;&#34;Checks if waveform is within the acceptable length

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform is not within the permitted length
        &#34;&#34;&#34;
        if (len(waveform) &lt; self._arbitrary_waveform_length[0]) or (
            len(waveform) &gt; self._arbitrary_waveform_length[1]
        ):
            msg = (
                &#34;The waveform is of length {}, which is not within the &#34;
                &#34;acceptable length {} &lt; len &lt; {}&#34;
                &#34;&#34;.format(len(waveform), *self._arbitrary_waveform_length)
            )
            raise ValueError(msg)

    def _check_arb_waveform_type_and_range(self, waveform: np.ndarray):
        &#34;&#34;&#34;Checks if waveform is of int/np.int32 type and within the resolution
        of the function generator

        Parameters
        ----------
        waveform : array_like
            Waveform or voltage list to be checked

        Raises
        ------
        ValueError
            If the waveform values are not int, np.uint16 or np.int32, or the
            values are not within the permitted range
        &#34;&#34;&#34;
        for value in waveform:
            if not isinstance(value, (int, np.uint16, np.int32)):
                raise ValueError(
                    &#34;The waveform contains values that are not&#34;
                    &#34;int, np.uint16 or np.int32&#34;
                )
            if (value &lt; 0) or (value &gt; self._arbitrary_waveform_resolution):
                raise ValueError(
                    f&#34;The waveform contains values out of range &#34;
                    f&#34;({value} is not within the resolution &#34;
                    f&#34;[0, {self._arbitrary_waveform_resolution}])&#34;
                )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tektronix_func_gen.FuncGen.instrument_limits"><code class="name">var <span class="ident">instrument_limits</span></code></dt>
<dd>
<div class="desc"><p>dict: Contains the following keys with subdictionaries</p>
<ul>
<li><code>frequency lims</code>
Containing the frequency limits for the instrument where the keys
"min" and "max" have values corresponding to minimum and maximum
frequencies in Hz</li>
<li><code>voltage lims</code>
Contains the maximum absolute voltage the instrument can output
for the keys "50ohm" and "highZ" according to the impedance setting</li>
<li><code>amplitude lims</code>
Contains the smallest and largest possible amplitudes where the
keys "50ohm" and "highZ" will have subdictionaries with keys
"min" and "max"</li>
</ul></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tektronix_func_gen.FuncGen.ch1"><code class="name">var <span class="ident">ch1</span></code></dt>
<dd>
<div class="desc"><p><code><a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel">FuncGenChannel</a></code>: Short hand for <code>channels[0]</code> Object to control channel 1</p></div>
</dd>
<dt id="tektronix_func_gen.FuncGen.ch2"><code class="name">var <span class="ident">ch2</span></code></dt>
<dd>
<div class="desc"><p><code><a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel">FuncGenChannel</a></code>: Short hand for <code>channels[1]</code> Object to control channel 2</p></div>
</dd>
<dt id="tektronix_func_gen.FuncGen.channels"><code class="name">var <span class="ident">channels</span></code></dt>
<dd>
<div class="desc"><p>tuple of <code><a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel">FuncGenChannel</a></code>: Objects to control the channels</p></div>
</dd>
<dt id="tektronix_func_gen.FuncGen.timeout"><code class="name">var <span class="ident">timeout</span> : int</code></dt>
<dd>
<div class="desc"><p>The timeout of the PYVISA connection in milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timeout(self) -&gt; int:
    &#34;&#34;&#34;The timeout of the PYVISA connection in milliseconds&#34;&#34;&#34;
    return self._inst.timeout</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"><p>bool: Choose whether to print information such as model upon connecting etc</p></div>
</dd>
<dt id="tektronix_func_gen.FuncGen.verify_param_set"><code class="name">var <span class="ident">verify_param_set</span></code></dt>
<dd>
<div class="desc"><p>bool:
Verify that a value is successfully set after executing a set function</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tektronix_func_gen.FuncGen.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the connection to the instrument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close the connection to the instrument&#34;&#34;&#34;
    if self._is_connected:
        self._inst.close()
        self._is_connected = False</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_custom_waveform"><code class="name flex">
<span>def <span class="ident">get_custom_waveform</span></span>(<span>self, memory_num: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get the waveform currently stored in USER<memory_num></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>memory_num</code></strong> :&ensp;<code>str</code> or <code>int {0,...,255}</code>, default <code>0</code></dt>
<dd>Select which user memory to compare with</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Waveform as ints spanning the resolution of the function gen or
and empty array if waveform not in use</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_waveform(self, memory_num: int) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the waveform currently stored in USER&lt;memory_num&gt;

    Parameters
    ----------
    memory_num : str or int {0,...,255}, default 0
        Select which user memory to compare with

    Returns
    -------
    waveform : ndarray
        Waveform as ints spanning the resolution of the function gen or
        and empty array if waveform not in use
    &#34;&#34;&#34;
    # Find the wavefroms in use
    waveforms_in_use = self.get_waveform_catalogue()
    if f&#34;USER{memory_num}&#34; in waveforms_in_use:
        # Copy the waveform to edit memory
        self.write(f&#34;DATA:COPY EMEMory,USER{memory_num}&#34;)
        # Get the length of the waveform
        waveform_length = int(self.query(&#34;DATA:POINts? EMEMory&#34;))
        # Get the waveform (returns binary values)
        waveform = self._inst.query_binary_values(
            &#34;DATA:DATA? EMEMory&#34;,
            datatype=&#34;H&#34;,
            is_big_endian=True,
            container=np.ndarray,
        )
        msg = (
            f&#34;Waveform length from native length command (DATA:POINts?) &#34;
            f&#34;and the processed binary values do not match, &#34;
            f&#34;{waveform_length} and {len(waveform)} respectively&#34;
        )
        assert len(waveform) == waveform_length, msg
        return waveform
    print(f&#34;Waveform USER{memory_num} is not in use&#34;)
    return np.array([])</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the contents of the Error/Event queue on the device</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Error/event number, description of error/event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error(self) -&gt; str:
    &#34;&#34;&#34;Get the contents of the Error/Event queue on the device

    Returns
    -------
    str
        Error/event number, description of error/event
    &#34;&#34;&#34;
    return self.query(&#34;SYSTEM:ERROR:NEXT?&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_frequency_lock"><code class="name flex">
<span>def <span class="ident">get_frequency_lock</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if frequency lock is enabled</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if frequency lock enabled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_lock(self) -&gt; bool:
    &#34;&#34;&#34;Check if frequency lock is enabled

    Returns
    -------
    bool
        `True` if frequency lock enabled
    &#34;&#34;&#34;
    # If one is locked so is the other, so just need to check one
    return int(self.query(&#34;SOURCE1:FREQuency:CONCurrent?&#34;)) == 1</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self) ‑> List[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Get dictionaries of the current settings of the two channels</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>list</code> of <code>dicts</code></dt>
<dd>[ch1_dict, ch2_dict]: Settings currently in use as a dictionary
with keys output, function, amplitude, offset, and frequency with
corresponding values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self) -&gt; List[dict]:
    &#34;&#34;&#34;Get dictionaries of the current settings of the two channels

    Returns
    -------
    settings : list of dicts
        [ch1_dict, ch2_dict]: Settings currently in use as a dictionary
        with keys output, function, amplitude, offset, and frequency with
        corresponding values
    &#34;&#34;&#34;
    return [ch.get_settings() for ch in self.channels]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.get_waveform_catalogue"><code class="name flex">
<span>def <span class="ident">get_waveform_catalogue</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of the waveforms that are in use (not empty)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>catalogue</code></strong> :&ensp;<code>list</code></dt>
<dd>Strings with the names of the user functions that are not empty</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_waveform_catalogue(self) -&gt; List[str]:
    &#34;&#34;&#34;Get list of the waveforms that are in use (not empty)

    Returns
    -------
    catalogue : list
        Strings with the names of the user functions that are not empty
    &#34;&#34;&#34;
    catalogue = self.query(&#34;DATA:CATalog?&#34;).split(&#34;,&#34;)
    catalogue = [wf[1:-1] for wf in catalogue]  # strip off extra quotes
    return catalogue</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, visa_address: str, timeout: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, visa_address: str, timeout: int):
    try:
        rm = pyvisa.ResourceManager()
        self._inst = rm.open_resource(visa_address)
    except pyvisa.Error:
        print(f&#34;\nVisaError: Could not connect to &#39;{visa_address}&#39;&#34;)
        raise
    self._is_connected = True
    self.timeout = timeout
    # Clear all the event registers and queues used in the instrument
    # status and event reporting system
    self.write(&#34;*CLS&#34;)
    # Get information about the connected device
    self._id = self.query(&#34;*IDN?&#34;)
    # Second query might be needed due to unknown reason
    if self._id == &#34;&#34;:
        self._id = self.query(&#34;*IDN?&#34;)
    self._maker, self._model, self._serial = self._id.split(&#34;,&#34;)[:3]
    if self.verbose:
        print(
            f&#34;Connected to {self._maker} model {self._model}, &#34;
            f&#34;serial {self._serial}&#34;
        )</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.print_settings"><code class="name flex">
<span>def <span class="ident">print_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints table of the current setting for both channels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_settings(self):
    &#34;&#34;&#34;Prints table of the current setting for both channels&#34;&#34;&#34;
    settings = self.get_settings()
    # Find the necessary padding for the table columns
    # by evaluating the maximum length of the entries
    key_padding = max([len(key) for key in settings[0].keys()])
    ch_paddings = [
        max([len(str(val[0])) for val in ch_settings.values()])
        for ch_settings in settings
    ]
    padding = [key_padding] + ch_paddings
    print(f&#34;\nCurrent settings for {self._maker} {self._model} {self._serial}\n&#34;)
    row_format = &#34;{:&gt;{padd[0]}s} {:{padd[1]}s} {:{padd[2]}s} {}&#34;
    table_header = row_format.format(&#34;Setting&#34;, &#34;Ch1&#34;, &#34;Ch2&#34;, &#34;Unit&#34;, padd=padding)
    print(table_header)
    print(&#34;=&#34; * len(table_header))
    for (ch1key, (ch1val, unit)), (_, (ch2val, _)) in zip(
        settings[0].items(), settings[1].items()
    ):
        print(
            row_format.format(ch1key, str(ch1val), str(ch2val), unit, padd=padding)
        )</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, command: str, custom_err_message: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Query the instrument</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA query command</dd>
<dt><strong><code>custom_err_message</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>When <code>None</code>, the RuntimeError message is "Writing/querying command
{command} failed: pyvisa returned StatusCode ..".
Otherwise, if a message is supplied "Could not {message}:
pyvisa returned StatusCode .."</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The instrument's response</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If status returned by PyVISA write command is not
<code>pyvisa.constants.StatusCode.success</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, command: str, custom_err_message: str = None) -&gt; str:
    &#34;&#34;&#34;Query the instrument

    Parameters
    ----------
    command : str
        The VISA query command
    custom_err_message : str, default `None`
        When `None`, the RuntimeError message is &#34;Writing/querying command
        {command} failed: pyvisa returned StatusCode ..&#34;.
        Otherwise, if a message is supplied &#34;Could not {message}:
        pyvisa returned StatusCode ..&#34;

    Returns
    -------
    str
        The instrument&#39;s response

    Raises
    ------
    RuntimeError
        If status returned by PyVISA write command is not
        `pyvisa.constants.StatusCode.success`
    &#34;&#34;&#34;
    response = self._inst.query(command).strip()
    self._check_pyvisa_status(command, custom_err_message=custom_err_message)
    return response</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_custom_waveform"><code class="name flex">
<span>def <span class="ident">set_custom_waveform</span></span>(<span>self, waveform: numpy.ndarray, normalise: bool = True, memory_num: int = 0, verify: bool = True, print_progress: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer waveform data to edit memory and then user memory.
NOTE: Will overwrite without warnings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Either unnormalised arbitrary waveform (then use <code>normalise=True</code>),
or ints spanning the resolution of the function generator</dd>
<dt><strong><code>normalise</code></strong> :&ensp;<code>bool</code></dt>
<dd>Choose whether to normalise the waveform to ints over the
resolution span of the function generator</dd>
<dt><strong><code>memory_num</code></strong> :&ensp;<code>str</code> or <code>int {0,...,255}</code>, default <code>0</code></dt>
<dd>Select which user memory to copy to</dd>
<dt><strong><code>verify</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Verify that the waveform has been transferred and is what was sent</dd>
<dt><strong><code>print_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>waveform</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The normalised waveform transferred</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the waveform is not within the permitted length or value range</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the waveform transferred to the instrument is of a different
length than the waveform supplied</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_waveform(
    self,
    waveform: np.ndarray,
    normalise: bool = True,
    memory_num: int = 0,
    verify: bool = True,
    print_progress: bool = True,
):
    &#34;&#34;&#34;Transfer waveform data to edit memory and then user memory.
    NOTE: Will overwrite without warnings

    Parameters
    ----------
    waveform : ndarray
        Either unnormalised arbitrary waveform (then use `normalise=True`),
        or ints spanning the resolution of the function generator
    normalise : bool
        Choose whether to normalise the waveform to ints over the
        resolution span of the function generator
    memory_num : str or int {0,...,255}, default 0
        Select which user memory to copy to
    verify : bool, default `True`
        Verify that the waveform has been transferred and is what was sent
    print_progress : bool, default `True`

    Returns
    -------
    waveform : ndarray
        The normalised waveform transferred

    Raises
    ------
    ValueError
        If the waveform is not within the permitted length or value range
    RuntimeError
        If the waveform transferred to the instrument is of a different
        length than the waveform supplied
    &#34;&#34;&#34;
    if not 0 &lt;= memory_num &lt;= self._max_waveform_memory_user_locations:
        raise ValueError(
            f&#34;The memory location {memory_num} is not a valid &#34;
            &#34;memory location for this model&#34;
        )
    # Check if waveform data is suitable
    if print_progress:
        print(&#34;Check if waveform data is suitable..&#34;, end=&#34; &#34;)
    self._check_arb_waveform_length(waveform)
    try:
        self._check_arb_waveform_type_and_range(waveform)
    except ValueError as err:
        if print_progress:
            print(f&#34;\n  {err}&#34;)
            print(&#34;Trying again normalising the waveform..&#34;, end=&#34; &#34;)
        waveform = self._normalise_to_waveform(waveform)
    if print_progress:
        print(&#34;ok&#34;)
        print(&#34;Transfer waveform to function generator..&#34;, end=&#34; &#34;)
    # Transfer waveform
    self._inst.write_binary_values(
        &#34;DATA:DATA EMEMory,&#34;, waveform, datatype=&#34;H&#34;, is_big_endian=True
    )
    # Check for errors and check lengths are matching
    transfer_error = self.get_error()
    emem_wf_length = self.query(&#34;DATA:POINts? EMEMory&#34;)
    if emem_wf_length == &#34;&#34; or not int(emem_wf_length) == len(waveform):
        msg = (
            f&#34;Waveform in temporary EMEMory has a length of {emem_wf_length}&#34;
            f&#34;, not of the same length as the waveform ({len(waveform)}).&#34;
            f&#34;\nError from the instrument: {transfer_error}&#34;
        )
        raise RuntimeError(msg)
    if print_progress:
        print(&#34;ok&#34;)
        print(f&#34;Copy waveform to USER{memory_num}..&#34;, end=&#34; &#34;)
    self.write(f&#34;DATA:COPY USER{memory_num},EMEMory&#34;)
    if print_progress:
        print(&#34;ok&#34;)
    if verify:
        if print_progress:
            print(f&#34;Verify waveform USER{memory_num}..&#34;)
        if f&#34;USER{memory_num}&#34; in self.get_waveform_catalogue():
            verif = self._verify_waveform(
                waveform,
                memory_num,
                normalise=normalise,
                print_result=print_progress,
            )
            if not verif[0]:
                raise RuntimeError(
                    f&#34;USER{memory_num} does not contain the waveform&#34;
                )
        else:
            raise RuntimeError(f&#34;USER{memory_num} is empty&#34;)
    return waveform</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_frequency_lock"><code class="name flex">
<span>def <span class="ident">set_frequency_lock</span></span>(<span>self, state: str, use_channel: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the frequency lock to make the two channels have the same
frequency and phase of their signals, also after adjustments.</p>
<p>See also <code><a title="tektronix_func_gen.FuncGen.syncronise_waveforms" href="#tektronix_func_gen.FuncGen.syncronise_waveforms">FuncGen.syncronise_waveforms()</a></code> for one-time sync only.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>{"ON", "OFF"}</code></dt>
<dd>ON to enable, OFF to disable the lock</dd>
<dt><strong><code>use_channel</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Only relevant if turning the lock ON: The channel whose frequency
shall be used as the common freqency</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency_lock(self, state: str, use_channel: int = 1):
    &#34;&#34;&#34;Enable the frequency lock to make the two channels have the same
    frequency and phase of their signals, also after adjustments.

    See also `FuncGen.syncronise_waveforms` for one-time sync only.

    Parameters
    ----------
    state : {&#34;ON&#34;, &#34;OFF&#34;}
        ON to enable, OFF to disable the lock
    use_channel : int, default 1
        Only relevant if turning the lock ON: The channel whose frequency
        shall be used as the common freqency
    &#34;&#34;&#34;
    if self.verbose:
        if state.lower() == &#34;off&#34; and not self.get_frequency_lock():
            print(
                f&#34;(!) {self._model}: Tried to disable frequency lock, but &#34;
                f&#34;frequency lock was not enabled&#34;
            )
            return
        if state.lower() == &#34;on&#34; and self.get_frequency_lock():
            print(
                f&#34;(!) {self._model}: Tried to enable frequency lock, but &#34;
                f&#34;frequency lock was already enabled&#34;
            )
            return
    # (Sufficient to disable for only one of the channels)
    cmd = f&#34;SOURCE{use_channel}:FREQuency:CONCurrent {state}&#34;
    msg = f&#34;turn frequency lock {state}&#34;
    self.write(cmd, custom_err_message=msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, settings: List[dict])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the settings of both channels with settings dictionaries</p>
<p>(Each channel is turned off before applying the changes to avoid
potentially harmful combinations)</p>
<h2 id="parameteres">Parameteres</h2>
<p>settings : list of dicts
List of settings dictionaries as returned by <code>get_settings</code>, first
entry for channel 1, second for channel 2. The dictionaries should
have keys output, function, amplitude, offset, and frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, settings: List[dict]):
    &#34;&#34;&#34;Set the settings of both channels with settings dictionaries

    (Each channel is turned off before applying the changes to avoid
    potentially harmful combinations)

    Parameteres
    -----------
    settings : list of dicts
        List of settings dictionaries as returned by `get_settings`, first
        entry for channel 1, second for channel 2. The dictionaries should
        have keys output, function, amplitude, offset, and frequency
    &#34;&#34;&#34;
    for ch, s in zip(self.channels, settings):
        ch.set_settings(s)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.software_trig"><code class="name flex">
<span>def <span class="ident">software_trig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>NOT TESTED: sends a trigger signal to the device
(for bursts or modulations)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def software_trig(self):
    &#34;&#34;&#34;NOT TESTED: sends a trigger signal to the device
    (for bursts or modulations)&#34;&#34;&#34;
    self.write(&#34;*TRG&#34;, custom_err_message=&#34;send trigger signal&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.syncronise_waveforms"><code class="name flex">
<span>def <span class="ident">syncronise_waveforms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Syncronise waveforms of the two channels when using the same frequency</p>
<p>Note: Does NOT enable the frequency lock that can be enabled on the
user interface of the instrument)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syncronise_waveforms(self):
    &#34;&#34;&#34;Syncronise waveforms of the two channels when using the same frequency

    Note: Does NOT enable the frequency lock that can be enabled on the
    user interface of the instrument)
    &#34;&#34;&#34;
    self.write(&#34;:PHAS:INIT&#34;, custom_err_message=&#34;syncronise waveforms&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGen.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, command: str, custom_err_message: str = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Write a VISA command to the instrument</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The VISA command to be written to the instrument</dd>
<dt><strong><code>custom_err_message</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>When <code>None</code>, the RuntimeError message is "Writing/querying command
{command} failed: pyvisa returned StatusCode ..".
Otherwise, if a message is supplied "Could not {message}:
pyvisa returned StatusCode .."</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bytes tranferred</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If status returned by PyVISA write command is not
<code>pyvisa.constants.StatusCode.success</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, command: str, custom_err_message: str = None) -&gt; int:
    &#34;&#34;&#34;Write a VISA command to the instrument

    Parameters
    ----------
    command : str
        The VISA command to be written to the instrument
    custom_err_message : str, default `None`
        When `None`, the RuntimeError message is &#34;Writing/querying command
        {command} failed: pyvisa returned StatusCode ..&#34;.
        Otherwise, if a message is supplied &#34;Could not {message}:
        pyvisa returned StatusCode ..&#34;

    Returns
    -------
    bytes : int
        Number of bytes tranferred

    Raises
    ------
    RuntimeError
        If status returned by PyVISA write command is not
        `pyvisa.constants.StatusCode.success`
    &#34;&#34;&#34;
    num_bytes = self._inst.write(command)
    self._check_pyvisa_status(command, custom_err_message=custom_err_message)
    return num_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel"><code class="flex name class">
<span>class <span class="ident">FuncGenChannel</span></span>
<span>(</span><span>fgen: <a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a>, channel: int, impedance: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for controlling a channel on a function generator object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fgen</code></strong> :&ensp;<code><a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a></code></dt>
<dd>The function generator object</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>{1, 2}</code></dt>
<dd>The channel to be controlled</dd>
<dt><strong><code>impedance</code></strong> :&ensp;<code>{"50ohm", "highZ"}</code></dt>
<dd>Determines voltage limits associated with high impedance (whether the
instrument is using 50ohm or high Z cannot be controlled through VISA)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_fgen</code></strong> :&ensp;<code><a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a></code></dt>
<dd>The function generator object for which the channel exists</dd>
<dt><strong><code>_channel</code></strong> :&ensp;<code>{1, 2}</code></dt>
<dd>The number of the channel this object is addressing</dd>
<dt><strong><code>_source</code></strong> :&ensp;<code>str</code></dt>
<dd>"SOURce{i}:" where {i} is the channel number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncGenChannel:
    &#34;&#34;&#34;Class for controlling a channel on a function generator object

    Parameters
    ----------
    fgen : `FuncGen`
        The function generator object
    channel : {1, 2}
        The channel to be controlled
    impedance : {&#34;50ohm&#34;, &#34;highZ&#34;}
        Determines voltage limits associated with high impedance (whether the
        instrument is using 50ohm or high Z cannot be controlled through VISA)

    Attributes
    ----------
    _fgen : `FuncGen`
        The function generator object for which the channel exists
    _channel : {1, 2}
        The number of the channel this object is addressing
    _source : str
        &#34;SOURce{i}:&#34; where {i} is the channel number
    &#34;&#34;&#34;

    _state_to_str = {&#34;1&#34;: &#34;ON&#34;, &#34;0&#34;: &#34;OFF&#34;, 1: &#34;ON&#34;, 0: &#34;OFF&#34;}
    &#34;&#34;&#34;Dictionary for converting output states to &#34;ON&#34; and &#34;OFF&#34; &#34;&#34;&#34;

    def __init__(self, fgen: FuncGen, channel: int, impedance: str):
        self._fgen = fgen
        self._channel = channel
        self._source = f&#34;SOURce{channel}:&#34;
        self.impedance = impedance
        &#34;&#34;&#34;{&#34;50ohm&#34;, &#34;highZ&#34;}: Determines voltage limits associated with high
        impedance (whether the instrument is using 50ohm or high Z cannot be
        controlled through VISA)&#34;&#34;&#34;
        # Adopt limits dictionary from instrument
        self.channel_limits = copy.deepcopy(self._fgen.instrument_limits)
        &#34;&#34;&#34;Channel limits for the individual channel, same form as
        `FuncGen.instrument_limits`&#34;&#34;&#34;

    def _impedance_dependent_limit(self, limit_type: str) -&gt; bool:
        &#34;&#34;&#34;Check if the limit type is impedance dependent (voltages) or
        not (frequency)

        Returns
        -------
        bool
            `True` if the limit is impedance dependent
        &#34;&#34;&#34;
        try:  # to access the key &#34;min&#34; to check if impedance must be selected
            _ = self.channel_limits[limit_type][0][&#34;min&#34;]
            return False
        except KeyError:  # if the key does not exist
            # The impedance must be selected
            return True

    def set_stricter_limits(self):
        &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
        through a series of prompts&#34;&#34;&#34;
        print(f&#34;Set stricter voltage and frequency limits for channel {self._channel}&#34;)
        print(&#34;Use enter only to leave a limit unchanged.&#34;)
        # Go through the different limits in the instrument_limits dict
        for limit_type, (inst_limit_dict, unit) in self._fgen.instrument_limits.items():
            use_impedance = self._impedance_dependent_limit(limit_type)
            print(f&#34;Set {limit_type} in {unit}&#34;, end=&#34; &#34;)
            if use_impedance:
                inst_limit_dict = inst_limit_dict[self.impedance]
                print(f&#34;[{self.impedance} impedance limit]&#34;)
            else:
                print(&#34;&#34;)  # get new line
            # Go through the min and max for the limit type
            for key, inst_value in inst_limit_dict.items():
                # prompt for new value
                new_value = input(f&#34;  {key} (instrument limit {inst_value}{unit}): &#34;)
                if new_value == &#34;&#34;:
                    # Do not change if empty
                    print(&#34;\tLimit not changed&#34;)
                else:
                    try:  # to convert to float
                        new_value = float(new_value)
                    except ValueError:
                        print(
                            f&#34;\tLimit unchanged: Could not convert &#39;{new_value}&#39; &#34;
                            f&#34;to float&#34;
                        )
                        continue  # to next item in dict
                    # Set the new limit
                    self.set_limit(limit_type, key, new_value, verbose=True)

    def set_limit(
        self, limit_type: str, bound: str, new_value: float, verbose: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
        self consistent (max larger than min)

        Parameterers
        ------------
        limit_type : str
            The name of the limit in the channel_limits dictionary
        bound : {&#34;min&#34;, &#34;max&#34;}
            Specifies if it is the max or the min limit that is to be set
        new_value : float
            The new value to be used for the limit
        verbose : bool
            Print confirmation that the limit was set or reason for why the
            limit was not set

        Returns
        -------
        bool
            `True` if new limit set, `False` otherwise
        &#34;&#34;&#34;
        # Short hand references
        inst_limit_dict = self._fgen.instrument_limits[limit_type]
        channel_limit_dict = self.channel_limits[limit_type]
        # Find the instrument limit and unit
        use_impedance = self._impedance_dependent_limit(limit_type)
        if use_impedance:
            inst_value = inst_limit_dict[0][self.impedance][bound]
        else:
            inst_value = inst_limit_dict[0][bound]
        unit = inst_limit_dict[1]
        # Check that the new value is within the intrument limits
        acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
        if use_impedance:
            current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
        else:
            current_min = channel_limit_dict[0][&#34;min&#34;]
        larger_than_min = new_value &gt; current_min
        acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
        if acceptable_min or acceptable_max:  # within the limits
            # Set the new channel_limit, using the impedance depending on the
            # limit type. Beware that the shorthand cannot be used, as this
            # only changes the shorthand not the dictionary itself
            if use_impedance:
                self.channel_limits[limit_type][0][self.impedance][bound] = new_value
            else:
                self.channel_limits[limit_type][0][bound] = new_value
            if verbose:
                print(f&#34;\tNew limit set {new_value}{unit}&#34;)
            return True
        if verbose:  # print description of why the limit was not set
            if larger_than_min:
                reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
                print(
                    f&#34;\tNew limit NOT set: {new_value}{unit} is {reason} than &#34;
                    f&#34;the instrument limit ({inst_value}{unit})&#34;
                )
            else:
                print(
                    f&#34;\tNew limit NOT set: {new_value}{unit} is smaller than the &#34;
                    f&#34;current set minimum ({current_min}{unit})&#34;
                )
        return False

    # Get currently used parameters from function generator
    def get_output_state(self) -&gt; int:
        &#34;&#34;&#34;Returns 0 for &#34;OFF&#34;, 1 for &#34;ON&#34; &#34;&#34;&#34;
        return int(self._fgen.query(f&#34;OUTPut{self._channel}:STATe?&#34;))

    def get_function(self) -&gt; str:
        &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
        return self._fgen.query(f&#34;{self._source}FUNCtion:SHAPe?&#34;)

    def get_amplitude(self) -&gt; float:
        &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}VOLTage:AMPLitude?&#34;))

    def get_offset(self) -&gt; float:
        &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}VOLTage:OFFSet?&#34;))

    def get_frequency(self) -&gt; float:
        &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
        return float(self._fgen.query(f&#34;{self._source}FREQuency?&#34;))

    # Get limits set in the channel class
    def get_frequency_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
        return [self.channel_limits[&#34;frequency lims&#34;][0][key] for key in [&#34;min&#34;, &#34;max&#34;]]

    def get_voltage_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
        return [
            self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]
        ]

    def get_amplitude_lims(self) -&gt; List[float]:
        &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
        return [
            self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
            for key in [&#34;min&#34;, &#34;max&#34;]
        ]

    def get_settings(self) -&gt; dict:
        &#34;&#34;&#34;Get the settings for the channel

        Returns
        -------
        current_settings : dict
            Settings currently in use as a dictionary with keys output,
            function, amplitude, offset, and frequency and values tuples of
            the corresponding return and unit
        &#34;&#34;&#34;
        return {
            &#34;output&#34;: (self._state_to_str[self.get_output_state()], &#34;&#34;),
            &#34;function&#34;: (self.get_function(), &#34;&#34;),
            &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
            &#34;offset&#34;: (self.get_offset(), &#34;V&#34;),
            &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;),
        }

    def print_settings(self):
        &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
        to use the `FuncGen.print_settings` for printing both channels)
        &#34;&#34;&#34;
        settings = self.get_settings()
        longest_key = max([len(key) for key in settings.keys()])
        print(&#34;\nCurrent settings for channel {}&#34;.format(self._channel))
        print(&#34;==============================&#34;)
        for key, (val, unit) in settings.items():
            print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit, num_char=longest_key))

    def set_settings(self, settings: dict):
        &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
        set the outout to OFF before applyign the settings (and turn the
        channel ON or leave it OFF depending on the settings dict)

        Parameteres
        -----------
        settings : dict
            Settings dictionary as returned by `get_settings`: should have
            keys output, function, amplitude, offset, and frequency
        &#34;&#34;&#34;
        # First turn off to ensure no potentially harmful
        # combination of settings
        self.set_output_state(&#34;OFF&#34;)
        # Set settings according to dictionary
        self.set_function(settings[&#34;function&#34;][0])
        self.set_amplitude(settings[&#34;amplitude&#34;][0])
        self.set_offset(settings[&#34;offset&#34;][0])
        self.set_frequency(settings[&#34;frequency&#34;][0])
        self.set_output_state(settings[&#34;output&#34;][0])

    def set_output_state(self, state: Union[int, str]):
        &#34;&#34;&#34;Enables or diables the output of the channel

        Parameters
        ----------
        state : int or str
            &#34;ON&#34; or int 1 to enable
            &#34;OFF&#34; or int 0 to disable

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        err_msg = f&#34;turn channel {self._channel} to state {state}&#34;
        self._fgen.write(
            f&#34;OUTPut{self._channel}:STATe {state}&#34;, custom_err_message=err_msg
        )
        if self._fgen.verify_param_set:
            actual_state = self.get_output_state()
            if not actual_state == state:
                msg = (
                    f&#34;Channel {self._channel} was not turned {state}, it is &#34;
                    f&#34;{self._state_to_str[actual_state]}.\n&#34;
                    f&#34;Error from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def get_output(self) -&gt; int:
        &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
        return self.get_output_state()

    def set_output(self, state: Union[int, str]):
        &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
        self.set_output_state(state)

    def set_function(self, shape: str):
        &#34;&#34;&#34;Set the function shape of the output

        Parameters
        ----------
        shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
                 USER1, ..., USER255, EMEMory, EFILe}
            &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
            AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
            OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
            Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
            BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
            Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
            Cardiac}

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        cmd = f&#34;{self._source}FUNCtion:SHAPe {shape}&#34;
        self._fgen.write(cmd, custom_err_message=f&#34;set function {shape}&#34;)
        if self._fgen.verify_param_set:
            actual_shape = self.get_function()
            if not actual_shape == shape:
                msg = (
                    f&#34;Function {shape} was not set on channel {self._channel}, &#34;
                    f&#34;it is {actual_shape}. Check that the function name is &#34;
                    f&#34;correctly spelt. Look up `set_function.__doc__` to see &#34;
                    f&#34;available shapes.\n Error from the instrument: &#34;
                    f&#34;{self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_amplitude(self, amplitude: float):
        &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

        Parameters
        ----------
        amplitude : float or {&#34;max&#34;, &#34;min&#34;}
            0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
            amplitude to the maximum or minimum limit given in `channel_limits`

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check if keyword min or max is given
        if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
            unit = &#34;&#34;  # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][
                str(amplitude).lower()
            ]
        else:
            unit = &#34;Vpp&#34;
            # Check if the given amplitude is within the current limits
            min_ampl, max_ampl = self.get_amplitude_lims()
            if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
                msg = (
                    f&#34;Could not set the amplitude {amplitude}{unit} as it &#34;
                    f&#34;is not within the amplitude limits set for the instrument &#34;
                    f&#34;[{min_ampl}, {max_ampl}]{unit}&#34;
                )
                raise NotSetError(msg)
        # Check that the new amplitude will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_offset = self.get_offset()
        if (
            amplitude / 2 - current_offset &lt; min_volt
            or amplitude / 2 + current_offset &gt; max_volt
        ):
            msg = (
                f&#34;Could not set the amplitude {amplitude}{unit} as the amplitude &#34;
                f&#34;combined with the offset ({current_offset}V) will be outside the &#34;
                f&#34;absolute voltage limits [{min_volt}, {max_volt}]{unit}&#34;
            )
            raise NotSetError(msg)
        # Set the amplitude
        cmd = f&#34;{self._source}VOLTage:LEVel {amplitude}{unit}&#34;
        err_msg = f&#34;set amplitude {amplitude}{unit}&#34;
        self._fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the amplitude has been set
        if self._fgen.verify_param_set:
            actual_amplitude = self.get_amplitude()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_amplitude = amplitude * _SI_prefix_to_factor(unit)
            else:
                check_amplitude = amplitude
            if not actual_amplitude == check_amplitude:
                msg = (
                    f&#34;Amplitude {amplitude}{unit} was not set on channel &#34;
                    f&#34;{self._channel}, it is {actual_amplitude}Vpp. Check that &#34;
                    f&#34; the number is within the possible range and in the &#34;
                    f&#34;correct format.\nError from the instrument: &#34;
                    f&#34;{self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_offset(self, offset: float, unit: str = &#34;V&#34;):
        &#34;&#34;&#34;Set offset in volts (or mV, see options)

        Parameters
        ----------
        offset : float
            Unknown resolution, guessing 0.1mV or four digits resolution
        unit : {mV, V}, default V

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        # Check that the new offset will not violate voltage limits
        min_volt, max_volt = self.get_voltage_lims()
        current_amplitude = self.get_amplitude()
        offset = _SI_prefix_to_factor(unit) * offset
        if (
            current_amplitude / 2 - offset &lt; min_volt
            or current_amplitude / 2 + offset &gt; max_volt
        ):
            msg = (
                f&#34;Could not set the offset {offset}V as the offset combined &#34;
                f&#34;with the amplitude ({current_amplitude}V) will be outside &#34;
                f&#34;the absolute voltage limits [{min_volt}, {max_volt}]V&#34;
            )
            raise NotSetError(msg)
        # Set the offset
        cmd = f&#34;{self._source}VOLTage:LEVel:OFFSet {offset}{unit}&#34;
        err_msg = f&#34;set offset {offset}{unit}&#34;
        self._fgen.write(cmd, custom_err_message=err_msg)
        # Verify that the offset has been set
        if self._fgen.verify_param_set:
            actual_offset = self.get_offset()
            # Multiply with the appropriate factor according to SI prefix
            check_offset = offset * _SI_prefix_to_factor(unit)
            if not actual_offset == check_offset:
                msg = (
                    f&#34;Offset {offset}{unit} was not set on channel &#34;
                    f&#34;{self._channel}, it is {actual_offset}V. Check that the &#34;
                    f&#34;number is within the possible range and in the correct &#34;
                    f&#34;format.\nError from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)

    def set_frequency(self, freq: float, unit: str = &#34;Hz&#34;):
        &#34;&#34;&#34;Set the frequency in Hertz (or mHz, kHz, MHz, see options)

        Parameters
        ----------
        freq : float
            The resolution is 1 μHz or 12 digits.
        unit : {mHz, Hz, kHz, MHz}, default Hz

        Raises
        ------
        NotSetError
            If `self._fgen.verify_param_set` is `True` and the value after
            applying the set function does not match the value returned by the
            get function
        &#34;&#34;&#34;
        if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]:  # handle min and max keywords
            unit = &#34;&#34;  # no unit for MIN/MAX
            # Look up what the limit is for this keyword
            freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
        else:
            # Check if the given frequency is within the current limits
            min_freq, max_freq = self.get_frequency_lims()
            freq = _SI_prefix_to_factor(unit) * freq
            if freq &lt; min_freq or freq &gt; max_freq:
                msg = (
                    f&#34;Could not set the frequency {freq}Hz as it is not &#34;
                    f&#34;within the frequency limits set for the instrument &#34;
                    f&#34;[{min_freq}, {max_freq}]Hz&#34;
                )
                raise NotSetError(msg)
        # Set the frequency
        self._fgen.write(
            f&#34;{self._source}FREQuency:FIXed {freq}{unit}&#34;,
            custom_err_message=f&#34;set frequency {freq}{unit}&#34;,
        )
        # Verify that the amplitude has been set
        if self._fgen.verify_param_set:
            actual_freq = self.get_frequency()
            # Multiply with the appropriate factor according to SI prefix, or
            # if string is empty, use the value looked up from channel_limits earlier
            if not unit == &#34;&#34;:
                check_freq = freq * _SI_prefix_to_factor(unit)
            else:
                check_freq = freq
            if not actual_freq == check_freq:
                msg = (
                    f&#34;Frequency {freq}{unit} was not set on channel {self._channel}&#34;
                    f&#34;, it is {actual_freq}Hz. Check that the number is within &#34;
                    f&#34;the possible range and in the correct format.\nError &#34;
                    f&#34;from the instrument: {self._fgen.get_error()}&#34;
                )
                raise NotSetError(msg)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tektronix_func_gen.FuncGenChannel.channel_limits"><code class="name">var <span class="ident">channel_limits</span></code></dt>
<dd>
<div class="desc"><p>Channel limits for the individual channel, same form as
<code><a title="tektronix_func_gen.FuncGen.instrument_limits" href="#tektronix_func_gen.FuncGen.instrument_limits">FuncGen.instrument_limits</a></code></p></div>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.impedance"><code class="name">var <span class="ident">impedance</span></code></dt>
<dd>
<div class="desc"><p>{"50ohm", "highZ"}: Determines voltage limits associated with high
impedance (whether the instrument is using 50ohm or high Z cannot be
controlled through VISA)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tektronix_func_gen.FuncGenChannel.get_amplitude"><code class="name flex">
<span>def <span class="ident">get_amplitude</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns peak-to-peak voltage in volts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_amplitude(self) -&gt; float:
    &#34;&#34;&#34;Returns peak-to-peak voltage in volts&#34;&#34;&#34;
    return float(self._fgen.query(f&#34;{self._source}VOLTage:AMPLitude?&#34;))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_amplitude_lims"><code class="name flex">
<span>def <span class="ident">get_amplitude_lims</span></span>(<span>self) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of min and max amplitude limits for the current impedance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_amplitude_lims(self) -&gt; List[float]:
    &#34;&#34;&#34;Returns list of min and max amplitude limits for the current impedance&#34;&#34;&#34;
    return [
        self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][key]
        for key in [&#34;min&#34;, &#34;max&#34;]
    ]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_frequency"><code class="name flex">
<span>def <span class="ident">get_frequency</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns frequency in Hertz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency(self) -&gt; float:
    &#34;&#34;&#34;Returns frequency in Hertz&#34;&#34;&#34;
    return float(self._fgen.query(f&#34;{self._source}FREQuency?&#34;))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_frequency_lims"><code class="name flex">
<span>def <span class="ident">get_frequency_lims</span></span>(<span>self) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of min and max frequency limits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_lims(self) -&gt; List[float]:
    &#34;&#34;&#34;Returns list of min and max frequency limits&#34;&#34;&#34;
    return [self.channel_limits[&#34;frequency lims&#34;][0][key] for key in [&#34;min&#34;, &#34;max&#34;]]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_function"><code class="name flex">
<span>def <span class="ident">get_function</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns string of function name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function(self) -&gt; str:
    &#34;&#34;&#34;Returns string of function name&#34;&#34;&#34;
    return self._fgen.query(f&#34;{self._source}FUNCtion:SHAPe?&#34;)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_offset"><code class="name flex">
<span>def <span class="ident">get_offset</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns offset voltage in volts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset(self) -&gt; float:
    &#34;&#34;&#34;Returns offset voltage in volts&#34;&#34;&#34;
    return float(self._fgen.query(f&#34;{self._source}VOLTage:OFFSet?&#34;))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for get_output_state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output(self) -&gt; int:
    &#34;&#34;&#34;Wrapper for get_output_state&#34;&#34;&#34;
    return self.get_output_state()</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_output_state"><code class="name flex">
<span>def <span class="ident">get_output_state</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns 0 for "OFF", 1 for "ON"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_state(self) -&gt; int:
    &#34;&#34;&#34;Returns 0 for &#34;OFF&#34;, 1 for &#34;ON&#34; &#34;&#34;&#34;
    return int(self._fgen.query(f&#34;OUTPut{self._channel}:STATe?&#34;))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the settings for the channel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>current_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>Settings currently in use as a dictionary with keys output,
function, amplitude, offset, and frequency and values tuples of
the corresponding return and unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self) -&gt; dict:
    &#34;&#34;&#34;Get the settings for the channel

    Returns
    -------
    current_settings : dict
        Settings currently in use as a dictionary with keys output,
        function, amplitude, offset, and frequency and values tuples of
        the corresponding return and unit
    &#34;&#34;&#34;
    return {
        &#34;output&#34;: (self._state_to_str[self.get_output_state()], &#34;&#34;),
        &#34;function&#34;: (self.get_function(), &#34;&#34;),
        &#34;amplitude&#34;: (self.get_amplitude(), &#34;Vpp&#34;),
        &#34;offset&#34;: (self.get_offset(), &#34;V&#34;),
        &#34;frequency&#34;: (self.get_frequency(), &#34;Hz&#34;),
    }</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.get_voltage_lims"><code class="name flex">
<span>def <span class="ident">get_voltage_lims</span></span>(<span>self) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of min and max voltage limits for the current impedance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_lims(self) -&gt; List[float]:
    &#34;&#34;&#34;Returns list of min and max voltage limits for the current impedance&#34;&#34;&#34;
    return [
        self.channel_limits[&#34;voltage lims&#34;][0][self.impedance][key]
        for key in [&#34;min&#34;, &#34;max&#34;]
    ]</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.print_settings"><code class="name flex">
<span>def <span class="ident">print_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the settings currently in use for the channel (Recommended
to use the <code><a title="tektronix_func_gen.FuncGen.print_settings" href="#tektronix_func_gen.FuncGen.print_settings">FuncGen.print_settings()</a></code> for printing both channels)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_settings(self):
    &#34;&#34;&#34;Print the settings currently in use for the channel (Recommended
    to use the `FuncGen.print_settings` for printing both channels)
    &#34;&#34;&#34;
    settings = self.get_settings()
    longest_key = max([len(key) for key in settings.keys()])
    print(&#34;\nCurrent settings for channel {}&#34;.format(self._channel))
    print(&#34;==============================&#34;)
    for key, (val, unit) in settings.items():
        print(&#34;{:&gt;{num_char}s} {} {}&#34;.format(key, val, unit, num_char=longest_key))</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_amplitude"><code class="name flex">
<span>def <span class="ident">set_amplitude</span></span>(<span>self, amplitude: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the peak-to-peak amplitude in volts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>amplitude</code></strong> :&ensp;<code>float</code> or <code>{"max", "min"}</code></dt>
<dd>0.1mV or four digits resolution, "max" or "min" will set the
amplitude to the maximum or minimum limit given in <code>channel_limits</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></dt>
<dd>If <code>self._fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_amplitude(self, amplitude: float):
    &#34;&#34;&#34;Set the peak-to-peak amplitude in volts

    Parameters
    ----------
    amplitude : float or {&#34;max&#34;, &#34;min&#34;}
        0.1mV or four digits resolution, &#34;max&#34; or &#34;min&#34; will set the
        amplitude to the maximum or minimum limit given in `channel_limits`

    Raises
    ------
    NotSetError
        If `self._fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    # Check if keyword min or max is given
    if str(amplitude).lower() in [&#34;min&#34;, &#34;max&#34;]:
        unit = &#34;&#34;  # no unit for MIN/MAX
        # Look up what the limit is for this keyword
        amplitude = self.channel_limits[&#34;amplitude lims&#34;][0][self.impedance][
            str(amplitude).lower()
        ]
    else:
        unit = &#34;Vpp&#34;
        # Check if the given amplitude is within the current limits
        min_ampl, max_ampl = self.get_amplitude_lims()
        if amplitude &lt; min_ampl or amplitude &gt; max_ampl:
            msg = (
                f&#34;Could not set the amplitude {amplitude}{unit} as it &#34;
                f&#34;is not within the amplitude limits set for the instrument &#34;
                f&#34;[{min_ampl}, {max_ampl}]{unit}&#34;
            )
            raise NotSetError(msg)
    # Check that the new amplitude will not violate voltage limits
    min_volt, max_volt = self.get_voltage_lims()
    current_offset = self.get_offset()
    if (
        amplitude / 2 - current_offset &lt; min_volt
        or amplitude / 2 + current_offset &gt; max_volt
    ):
        msg = (
            f&#34;Could not set the amplitude {amplitude}{unit} as the amplitude &#34;
            f&#34;combined with the offset ({current_offset}V) will be outside the &#34;
            f&#34;absolute voltage limits [{min_volt}, {max_volt}]{unit}&#34;
        )
        raise NotSetError(msg)
    # Set the amplitude
    cmd = f&#34;{self._source}VOLTage:LEVel {amplitude}{unit}&#34;
    err_msg = f&#34;set amplitude {amplitude}{unit}&#34;
    self._fgen.write(cmd, custom_err_message=err_msg)
    # Verify that the amplitude has been set
    if self._fgen.verify_param_set:
        actual_amplitude = self.get_amplitude()
        # Multiply with the appropriate factor according to SI prefix, or
        # if string is empty, use the value looked up from channel_limits earlier
        if not unit == &#34;&#34;:
            check_amplitude = amplitude * _SI_prefix_to_factor(unit)
        else:
            check_amplitude = amplitude
        if not actual_amplitude == check_amplitude:
            msg = (
                f&#34;Amplitude {amplitude}{unit} was not set on channel &#34;
                f&#34;{self._channel}, it is {actual_amplitude}Vpp. Check that &#34;
                f&#34; the number is within the possible range and in the &#34;
                f&#34;correct format.\nError from the instrument: &#34;
                f&#34;{self._fgen.get_error()}&#34;
            )
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_frequency"><code class="name flex">
<span>def <span class="ident">set_frequency</span></span>(<span>self, freq: float, unit: str = 'Hz')</span>
</code></dt>
<dd>
<div class="desc"><p>Set the frequency in Hertz (or mHz, kHz, MHz, see options)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code></dt>
<dd>The resolution is 1 μHz or 12 digits.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{mHz, Hz, kHz, MHz}</code>, default <code>Hz</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></dt>
<dd>If <code>self._fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency(self, freq: float, unit: str = &#34;Hz&#34;):
    &#34;&#34;&#34;Set the frequency in Hertz (or mHz, kHz, MHz, see options)

    Parameters
    ----------
    freq : float
        The resolution is 1 μHz or 12 digits.
    unit : {mHz, Hz, kHz, MHz}, default Hz

    Raises
    ------
    NotSetError
        If `self._fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    if str(freq).lower() in [&#34;min&#34;, &#34;max&#34;]:  # handle min and max keywords
        unit = &#34;&#34;  # no unit for MIN/MAX
        # Look up what the limit is for this keyword
        freq = self.channel_limits[&#34;frequency lims&#34;][0][str(freq).lower()]
    else:
        # Check if the given frequency is within the current limits
        min_freq, max_freq = self.get_frequency_lims()
        freq = _SI_prefix_to_factor(unit) * freq
        if freq &lt; min_freq or freq &gt; max_freq:
            msg = (
                f&#34;Could not set the frequency {freq}Hz as it is not &#34;
                f&#34;within the frequency limits set for the instrument &#34;
                f&#34;[{min_freq}, {max_freq}]Hz&#34;
            )
            raise NotSetError(msg)
    # Set the frequency
    self._fgen.write(
        f&#34;{self._source}FREQuency:FIXed {freq}{unit}&#34;,
        custom_err_message=f&#34;set frequency {freq}{unit}&#34;,
    )
    # Verify that the amplitude has been set
    if self._fgen.verify_param_set:
        actual_freq = self.get_frequency()
        # Multiply with the appropriate factor according to SI prefix, or
        # if string is empty, use the value looked up from channel_limits earlier
        if not unit == &#34;&#34;:
            check_freq = freq * _SI_prefix_to_factor(unit)
        else:
            check_freq = freq
        if not actual_freq == check_freq:
            msg = (
                f&#34;Frequency {freq}{unit} was not set on channel {self._channel}&#34;
                f&#34;, it is {actual_freq}Hz. Check that the number is within &#34;
                f&#34;the possible range and in the correct format.\nError &#34;
                f&#34;from the instrument: {self._fgen.get_error()}&#34;
            )
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_function"><code class="name flex">
<span>def <span class="ident">set_function</span></span>(<span>self, shape: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the function shape of the output</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>{SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],</code></dt>
<dd>USER1, &hellip;, USER255, EMEMory, EFILe}
<Built_in>::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
Cardiac}</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></dt>
<dd>If <code>self._fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_function(self, shape: str):
    &#34;&#34;&#34;Set the function shape of the output

    Parameters
    ----------
    shape : {SINusoid, SQUare, PULSe, RAMP, PRNoise, &lt;Built_in&gt;, USER[0],
             USER1, ..., USER255, EMEMory, EFILe}
        &lt;Built_in&gt;::={StairDown|StairUp|Stair Up&amp;Dwn|Trapezoid|RoundHalf|
        AbsSine|AbsHalfSine|ClippedSine|ChoppedSine|NegRamp|OscRise|
        OscDecay|CodedPulse|PosPulse|NegPulse|ExpRise|ExpDecay|Sinc|
        Tan|Cotan|SquareRoot|X^2|HaverSine|Lorentz|Ln(x)|X^3|CauchyDistr|
        BesselJ|BesselY|ErrorFunc|Airy|Rectangle|Gauss|Hamming|Hanning|
        Bartlett|Blackman|Laylight|Triangle|DC|Heart|Round|Chirp|Rhombus|
        Cardiac}

    Raises
    ------
    NotSetError
        If `self._fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    cmd = f&#34;{self._source}FUNCtion:SHAPe {shape}&#34;
    self._fgen.write(cmd, custom_err_message=f&#34;set function {shape}&#34;)
    if self._fgen.verify_param_set:
        actual_shape = self.get_function()
        if not actual_shape == shape:
            msg = (
                f&#34;Function {shape} was not set on channel {self._channel}, &#34;
                f&#34;it is {actual_shape}. Check that the function name is &#34;
                f&#34;correctly spelt. Look up `set_function.__doc__` to see &#34;
                f&#34;available shapes.\n Error from the instrument: &#34;
                f&#34;{self._fgen.get_error()}&#34;
            )
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_limit"><code class="name flex">
<span>def <span class="ident">set_limit</span></span>(<span>self, limit_type: str, bound: str, new_value: float, verbose: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Set a limit if the new value is within the instrument limits and are
self consistent (max larger than min)</p>
<h2 id="parameterers">Parameterers</h2>
<p>limit_type : str
The name of the limit in the channel_limits dictionary
bound : {"min", "max"}
Specifies if it is the max or the min limit that is to be set
new_value : float
The new value to be used for the limit
verbose : bool
Print confirmation that the limit was set or reason for why the
limit was not set</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if new limit set, <code>False</code> otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_limit(
    self, limit_type: str, bound: str, new_value: float, verbose: bool = False
) -&gt; bool:
    &#34;&#34;&#34;Set a limit if the new value is within the instrument limits and are
    self consistent (max larger than min)

    Parameterers
    ------------
    limit_type : str
        The name of the limit in the channel_limits dictionary
    bound : {&#34;min&#34;, &#34;max&#34;}
        Specifies if it is the max or the min limit that is to be set
    new_value : float
        The new value to be used for the limit
    verbose : bool
        Print confirmation that the limit was set or reason for why the
        limit was not set

    Returns
    -------
    bool
        `True` if new limit set, `False` otherwise
    &#34;&#34;&#34;
    # Short hand references
    inst_limit_dict = self._fgen.instrument_limits[limit_type]
    channel_limit_dict = self.channel_limits[limit_type]
    # Find the instrument limit and unit
    use_impedance = self._impedance_dependent_limit(limit_type)
    if use_impedance:
        inst_value = inst_limit_dict[0][self.impedance][bound]
    else:
        inst_value = inst_limit_dict[0][bound]
    unit = inst_limit_dict[1]
    # Check that the new value is within the intrument limits
    acceptable_min = bound == &#34;min&#34; and new_value &gt; inst_value
    if use_impedance:
        current_min = channel_limit_dict[0][self.impedance][&#34;min&#34;]
    else:
        current_min = channel_limit_dict[0][&#34;min&#34;]
    larger_than_min = new_value &gt; current_min
    acceptable_max = bound == &#34;max&#34; and new_value &lt; inst_value and larger_than_min
    if acceptable_min or acceptable_max:  # within the limits
        # Set the new channel_limit, using the impedance depending on the
        # limit type. Beware that the shorthand cannot be used, as this
        # only changes the shorthand not the dictionary itself
        if use_impedance:
            self.channel_limits[limit_type][0][self.impedance][bound] = new_value
        else:
            self.channel_limits[limit_type][0][bound] = new_value
        if verbose:
            print(f&#34;\tNew limit set {new_value}{unit}&#34;)
        return True
    if verbose:  # print description of why the limit was not set
        if larger_than_min:
            reason = &#34;larger&#34; if bound == &#34;max&#34; else &#34;smaller&#34;
            print(
                f&#34;\tNew limit NOT set: {new_value}{unit} is {reason} than &#34;
                f&#34;the instrument limit ({inst_value}{unit})&#34;
            )
        else:
            print(
                f&#34;\tNew limit NOT set: {new_value}{unit} is smaller than the &#34;
                f&#34;current set minimum ({current_min}{unit})&#34;
            )
    return False</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_offset"><code class="name flex">
<span>def <span class="ident">set_offset</span></span>(<span>self, offset: float, unit: str = 'V')</span>
</code></dt>
<dd>
<div class="desc"><p>Set offset in volts (or mV, see options)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Unknown resolution, guessing 0.1mV or four digits resolution</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{mV, V}</code>, default <code>V</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></dt>
<dd>If <code>self._fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_offset(self, offset: float, unit: str = &#34;V&#34;):
    &#34;&#34;&#34;Set offset in volts (or mV, see options)

    Parameters
    ----------
    offset : float
        Unknown resolution, guessing 0.1mV or four digits resolution
    unit : {mV, V}, default V

    Raises
    ------
    NotSetError
        If `self._fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    # Check that the new offset will not violate voltage limits
    min_volt, max_volt = self.get_voltage_lims()
    current_amplitude = self.get_amplitude()
    offset = _SI_prefix_to_factor(unit) * offset
    if (
        current_amplitude / 2 - offset &lt; min_volt
        or current_amplitude / 2 + offset &gt; max_volt
    ):
        msg = (
            f&#34;Could not set the offset {offset}V as the offset combined &#34;
            f&#34;with the amplitude ({current_amplitude}V) will be outside &#34;
            f&#34;the absolute voltage limits [{min_volt}, {max_volt}]V&#34;
        )
        raise NotSetError(msg)
    # Set the offset
    cmd = f&#34;{self._source}VOLTage:LEVel:OFFSet {offset}{unit}&#34;
    err_msg = f&#34;set offset {offset}{unit}&#34;
    self._fgen.write(cmd, custom_err_message=err_msg)
    # Verify that the offset has been set
    if self._fgen.verify_param_set:
        actual_offset = self.get_offset()
        # Multiply with the appropriate factor according to SI prefix
        check_offset = offset * _SI_prefix_to_factor(unit)
        if not actual_offset == check_offset:
            msg = (
                f&#34;Offset {offset}{unit} was not set on channel &#34;
                f&#34;{self._channel}, it is {actual_offset}V. Check that the &#34;
                f&#34;number is within the possible range and in the correct &#34;
                f&#34;format.\nError from the instrument: {self._fgen.get_error()}&#34;
            )
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, state: Union[int, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for set_output_state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, state: Union[int, str]):
    &#34;&#34;&#34;Wrapper for set_output_state&#34;&#34;&#34;
    self.set_output_state(state)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_output_state"><code class="name flex">
<span>def <span class="ident">set_output_state</span></span>(<span>self, state: Union[int, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Enables or diables the output of the channel</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>"ON" or int 1 to enable
"OFF" or int 0 to disable</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></dt>
<dd>If <code>self._fgen.verify_param_set</code> is <code>True</code> and the value after
applying the set function does not match the value returned by the
get function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output_state(self, state: Union[int, str]):
    &#34;&#34;&#34;Enables or diables the output of the channel

    Parameters
    ----------
    state : int or str
        &#34;ON&#34; or int 1 to enable
        &#34;OFF&#34; or int 0 to disable

    Raises
    ------
    NotSetError
        If `self._fgen.verify_param_set` is `True` and the value after
        applying the set function does not match the value returned by the
        get function
    &#34;&#34;&#34;
    err_msg = f&#34;turn channel {self._channel} to state {state}&#34;
    self._fgen.write(
        f&#34;OUTPut{self._channel}:STATe {state}&#34;, custom_err_message=err_msg
    )
    if self._fgen.verify_param_set:
        actual_state = self.get_output_state()
        if not actual_state == state:
            msg = (
                f&#34;Channel {self._channel} was not turned {state}, it is &#34;
                f&#34;{self._state_to_str[actual_state]}.\n&#34;
                f&#34;Error from the instrument: {self._fgen.get_error()}&#34;
            )
            raise NotSetError(msg)</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, settings: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the settings of the channel with a settings dictionary. Will
set the outout to OFF before applyign the settings (and turn the
channel ON or leave it OFF depending on the settings dict)</p>
<h2 id="parameteres">Parameteres</h2>
<p>settings : dict
Settings dictionary as returned by <code>get_settings</code>: should have
keys output, function, amplitude, offset, and frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, settings: dict):
    &#34;&#34;&#34;Set the settings of the channel with a settings dictionary. Will
    set the outout to OFF before applyign the settings (and turn the
    channel ON or leave it OFF depending on the settings dict)

    Parameteres
    -----------
    settings : dict
        Settings dictionary as returned by `get_settings`: should have
        keys output, function, amplitude, offset, and frequency
    &#34;&#34;&#34;
    # First turn off to ensure no potentially harmful
    # combination of settings
    self.set_output_state(&#34;OFF&#34;)
    # Set settings according to dictionary
    self.set_function(settings[&#34;function&#34;][0])
    self.set_amplitude(settings[&#34;amplitude&#34;][0])
    self.set_offset(settings[&#34;offset&#34;][0])
    self.set_frequency(settings[&#34;frequency&#34;][0])
    self.set_output_state(settings[&#34;output&#34;][0])</code></pre>
</details>
</dd>
<dt id="tektronix_func_gen.FuncGenChannel.set_stricter_limits"><code class="name flex">
<span>def <span class="ident">set_stricter_limits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set limits for the voltage and frequency limits of the channel output
through a series of prompts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stricter_limits(self):
    &#34;&#34;&#34;Set limits for the voltage and frequency limits of the channel output
    through a series of prompts&#34;&#34;&#34;
    print(f&#34;Set stricter voltage and frequency limits for channel {self._channel}&#34;)
    print(&#34;Use enter only to leave a limit unchanged.&#34;)
    # Go through the different limits in the instrument_limits dict
    for limit_type, (inst_limit_dict, unit) in self._fgen.instrument_limits.items():
        use_impedance = self._impedance_dependent_limit(limit_type)
        print(f&#34;Set {limit_type} in {unit}&#34;, end=&#34; &#34;)
        if use_impedance:
            inst_limit_dict = inst_limit_dict[self.impedance]
            print(f&#34;[{self.impedance} impedance limit]&#34;)
        else:
            print(&#34;&#34;)  # get new line
        # Go through the min and max for the limit type
        for key, inst_value in inst_limit_dict.items():
            # prompt for new value
            new_value = input(f&#34;  {key} (instrument limit {inst_value}{unit}): &#34;)
            if new_value == &#34;&#34;:
                # Do not change if empty
                print(&#34;\tLimit not changed&#34;)
            else:
                try:  # to convert to float
                    new_value = float(new_value)
                except ValueError:
                    print(
                        f&#34;\tLimit unchanged: Could not convert &#39;{new_value}&#39; &#34;
                        f&#34;to float&#34;
                    )
                    continue  # to next item in dict
                # Set the new limit
                self.set_limit(limit_type, key, new_value, verbose=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tektronix_func_gen.NotCompatibleError"><code class="flex name class">
<span>class <span class="ident">NotCompatibleError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Error for when the instrument is not compatible with this module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotCompatibleError(Exception):
    &#34;&#34;&#34;Error for when the instrument is not compatible with this module&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tektronix_func_gen.NotSetError"><code class="flex name class">
<span>class <span class="ident">NotSetError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Error for when a value cannot be written to the instrument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotSetError(Exception):
    &#34;&#34;&#34;Error for when a value cannot be written to the instrument&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tektronix-arbitrary-function-generator-control">Tektronix arbitrary function generator control</a><ul>
<li><a href="#known-issues">Known issues</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage-through-examples">Usage (through examples)</a><ul>
<li><a href="#syncronisation-and-frequency-lock">Syncronisation and frequency lock</a></li>
<li><a href="#arbitrary-waveforms">Arbitrary waveforms</a><ul>
<li><a href="#flat-function-offset-control">Flat function offset control</a></li>
</ul>
</li>
<li><a href="#set-voltage-and-frequency-limits">Set voltage and frequency limits</a></li>
<li><a href="#impedance">Impedance</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tektronix_func_gen.example_basic_control" href="#tektronix_func_gen.example_basic_control">example_basic_control</a></code></li>
<li><code><a title="tektronix_func_gen.example_change_settings" href="#tektronix_func_gen.example_change_settings">example_change_settings</a></code></li>
<li><code><a title="tektronix_func_gen.example_changing_limits" href="#tektronix_func_gen.example_changing_limits">example_changing_limits</a></code></li>
<li><code><a title="tektronix_func_gen.example_lock_frequencies" href="#tektronix_func_gen.example_lock_frequencies">example_lock_frequencies</a></code></li>
<li><code><a title="tektronix_func_gen.example_set_and_use_custom_waveform" href="#tektronix_func_gen.example_set_and_use_custom_waveform">example_set_and_use_custom_waveform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tektronix_func_gen.FuncGen" href="#tektronix_func_gen.FuncGen">FuncGen</a></code></h4>
<ul class="">
<li><code><a title="tektronix_func_gen.FuncGen.ch1" href="#tektronix_func_gen.FuncGen.ch1">ch1</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.ch2" href="#tektronix_func_gen.FuncGen.ch2">ch2</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.channels" href="#tektronix_func_gen.FuncGen.channels">channels</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.close" href="#tektronix_func_gen.FuncGen.close">close</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_custom_waveform" href="#tektronix_func_gen.FuncGen.get_custom_waveform">get_custom_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_error" href="#tektronix_func_gen.FuncGen.get_error">get_error</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_frequency_lock" href="#tektronix_func_gen.FuncGen.get_frequency_lock">get_frequency_lock</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_settings" href="#tektronix_func_gen.FuncGen.get_settings">get_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.get_waveform_catalogue" href="#tektronix_func_gen.FuncGen.get_waveform_catalogue">get_waveform_catalogue</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.instrument_limits" href="#tektronix_func_gen.FuncGen.instrument_limits">instrument_limits</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.open" href="#tektronix_func_gen.FuncGen.open">open</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.print_settings" href="#tektronix_func_gen.FuncGen.print_settings">print_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.query" href="#tektronix_func_gen.FuncGen.query">query</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_custom_waveform" href="#tektronix_func_gen.FuncGen.set_custom_waveform">set_custom_waveform</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_frequency_lock" href="#tektronix_func_gen.FuncGen.set_frequency_lock">set_frequency_lock</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.set_settings" href="#tektronix_func_gen.FuncGen.set_settings">set_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.software_trig" href="#tektronix_func_gen.FuncGen.software_trig">software_trig</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.syncronise_waveforms" href="#tektronix_func_gen.FuncGen.syncronise_waveforms">syncronise_waveforms</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.timeout" href="#tektronix_func_gen.FuncGen.timeout">timeout</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.verbose" href="#tektronix_func_gen.FuncGen.verbose">verbose</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.verify_param_set" href="#tektronix_func_gen.FuncGen.verify_param_set">verify_param_set</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGen.write" href="#tektronix_func_gen.FuncGen.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tektronix_func_gen.FuncGenChannel" href="#tektronix_func_gen.FuncGenChannel">FuncGenChannel</a></code></h4>
<ul class="two-column">
<li><code><a title="tektronix_func_gen.FuncGenChannel.channel_limits" href="#tektronix_func_gen.FuncGenChannel.channel_limits">channel_limits</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_amplitude" href="#tektronix_func_gen.FuncGenChannel.get_amplitude">get_amplitude</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_amplitude_lims" href="#tektronix_func_gen.FuncGenChannel.get_amplitude_lims">get_amplitude_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_frequency" href="#tektronix_func_gen.FuncGenChannel.get_frequency">get_frequency</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_frequency_lims" href="#tektronix_func_gen.FuncGenChannel.get_frequency_lims">get_frequency_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_function" href="#tektronix_func_gen.FuncGenChannel.get_function">get_function</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_offset" href="#tektronix_func_gen.FuncGenChannel.get_offset">get_offset</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_output" href="#tektronix_func_gen.FuncGenChannel.get_output">get_output</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_output_state" href="#tektronix_func_gen.FuncGenChannel.get_output_state">get_output_state</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_settings" href="#tektronix_func_gen.FuncGenChannel.get_settings">get_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.get_voltage_lims" href="#tektronix_func_gen.FuncGenChannel.get_voltage_lims">get_voltage_lims</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.impedance" href="#tektronix_func_gen.FuncGenChannel.impedance">impedance</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.print_settings" href="#tektronix_func_gen.FuncGenChannel.print_settings">print_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_amplitude" href="#tektronix_func_gen.FuncGenChannel.set_amplitude">set_amplitude</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_frequency" href="#tektronix_func_gen.FuncGenChannel.set_frequency">set_frequency</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_function" href="#tektronix_func_gen.FuncGenChannel.set_function">set_function</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_limit" href="#tektronix_func_gen.FuncGenChannel.set_limit">set_limit</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_offset" href="#tektronix_func_gen.FuncGenChannel.set_offset">set_offset</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_output" href="#tektronix_func_gen.FuncGenChannel.set_output">set_output</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_output_state" href="#tektronix_func_gen.FuncGenChannel.set_output_state">set_output_state</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_settings" href="#tektronix_func_gen.FuncGenChannel.set_settings">set_settings</a></code></li>
<li><code><a title="tektronix_func_gen.FuncGenChannel.set_stricter_limits" href="#tektronix_func_gen.FuncGenChannel.set_stricter_limits">set_stricter_limits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tektronix_func_gen.NotCompatibleError" href="#tektronix_func_gen.NotCompatibleError">NotCompatibleError</a></code></h4>
</li>
<li>
<h4><code><a title="tektronix_func_gen.NotSetError" href="#tektronix_func_gen.NotSetError">NotSetError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>